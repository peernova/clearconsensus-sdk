# coding: utf-8

"""
    clearconsensus-sdk

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ValidatorServiceApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def validator_service_add_validation_rule(self, body, **kwargs):  # noqa: E501
        """AddValidationRule is a method used to add a validation rule to the system. Backoffice users can create a new validation ruleset in the 'global' scope, for each asset class. Participant users can create a new validation ruleset in its own scope, for each asset class. Backoffice users can represent any participant and create a new validation ruleset in that participant's scope. The default scope is used if no scope is given in the request ('global' for the operator, participant scope for that participant user). The authorization will be fetched from the user's token. It will do an update if a validation rule with the same name already exists.  # noqa: E501

        Request for backoffice user: { \"definition\": {   \"descriptor_name\":\"foreign_exchange-vanilla-options\",   \"criteria\":[     {       \"name\":\"FX-V-FXO: Option Instrument Parameter: Forward Points\",       \"description\":\"This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \\\"Forward Points\\\".\",       \"tags\":[         \"forward points\"       ],       \"metadata\":[        ],       \"rule\":\"[\\\"foreign_exchange-vanilla-options.option_instrument_parameter\\\",\\\"$eq_case_insensitive\\\",\\\"Forward Points\\\"]\",       \"validations\":[         {           \"name\":\"FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check\",           \"severity\":1,           \"rule_type\":\"input_data\",           \"tags\":[            ],           \"description\":\"Compare the fwrd_conversion_factor for a given underlying against the expected values.\",           \"rule\":\"[ { \\\"$lut_name\\\": \\\"conversion_factor\\\", \\\"$get\\\": [ \\\"foreign_exchange-vanilla-options.underlying\\\" ] }, \\\"$eq\\\", \\\"foreign_exchange-vanilla-options.fwrd_conversion_factor\\\" ]\",           \"error\":{             \"message\":\"[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].\",             \"message_args\":[               \"foreign_exchange-vanilla-options.fwrd_conversion_factor\",               \"foreign_exchange-vanilla-options.underlying\"             ]           }         }       ]     }   ] }, \"scope\": \"global\", \"descriptor_name\": \"foreign_exchange-vanilla-options\" }  Response: {    \"data\": {        \"uid\": \"ac49453d-cc9c-11ec-8bac-5314d58ea570\",        \"descriptor_name\": \"fx_forward\"    } }  Error response:  Push to non ‘global’ scope : {    \"error\": {        \"code\": 70,        \"message\": \"Invalid argument: only support 'global' scope\"    } }  Unauthorized user : {    \"error\": {        \"code\": 70,        \"message\": \"Invalid auth token - only operator is allowed to add validation rules\"    } }  Missing argument : {    \"error\": {        \"code\": 70,        \"message\": \"Missing argument: descriptor_name\"    } }  Invalid rule definition - rule col mismatch with descriptor : {    \"error\": {        \"code\": 70,        \"message\": \"Rule [fx_fwd] compile failed, details: Column [submission_clienttt] not found in schema [fx_forward]\"    } }  Invalid rule definition - RDL syntax error : {    \"error\": {        \"code\": 70,        \"message\": \"Rule [fx_fwd] compile failed, details: line 1:14 no viable alternative at input '[{\\\"$lower\\\":\\\"fx_forward.submission_service\\\"'\"    } }  Dependencies not found - dependencies could be: descriptor, named lut, custom function : {    \"error\": {        \"code\": 70,        \"message\": \"Rule [fx_fwd] compile failed, details: Invalid rule expression [ { \\\"$lut_name\\\" : \\\"tenor\\\", \\\"$exist\\\" : [\\\"fx_forward.submission_tenor\\\"] } ]\\n\\terr: com.peernova.api.searchmetadata.metadata.exceptions.MetadataNotFoundException: No Look Up Table by name [tenor] found in scope [global]\"    } }  Ruleset with same name already exist : {    \"error\": {        \"code\": 70,        \"message\": \"Validation rule for descriptor [fx_fwd] already exist\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_add_validation_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumValidationRuleDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumAcknowledgeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_add_validation_rule_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_add_validation_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """AddValidationRule is a method used to add a validation rule to the system. Backoffice users can create a new validation ruleset in the 'global' scope, for each asset class. Participant users can create a new validation ruleset in its own scope, for each asset class. Backoffice users can represent any participant and create a new validation ruleset in that participant's scope. The default scope is used if no scope is given in the request ('global' for the operator, participant scope for that participant user). The authorization will be fetched from the user's token. It will do an update if a validation rule with the same name already exists.  # noqa: E501

        Request for backoffice user: { \"definition\": {   \"descriptor_name\":\"foreign_exchange-vanilla-options\",   \"criteria\":[     {       \"name\":\"FX-V-FXO: Option Instrument Parameter: Forward Points\",       \"description\":\"This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \\\"Forward Points\\\".\",       \"tags\":[         \"forward points\"       ],       \"metadata\":[        ],       \"rule\":\"[\\\"foreign_exchange-vanilla-options.option_instrument_parameter\\\",\\\"$eq_case_insensitive\\\",\\\"Forward Points\\\"]\",       \"validations\":[         {           \"name\":\"FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check\",           \"severity\":1,           \"rule_type\":\"input_data\",           \"tags\":[            ],           \"description\":\"Compare the fwrd_conversion_factor for a given underlying against the expected values.\",           \"rule\":\"[ { \\\"$lut_name\\\": \\\"conversion_factor\\\", \\\"$get\\\": [ \\\"foreign_exchange-vanilla-options.underlying\\\" ] }, \\\"$eq\\\", \\\"foreign_exchange-vanilla-options.fwrd_conversion_factor\\\" ]\",           \"error\":{             \"message\":\"[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].\",             \"message_args\":[               \"foreign_exchange-vanilla-options.fwrd_conversion_factor\",               \"foreign_exchange-vanilla-options.underlying\"             ]           }         }       ]     }   ] }, \"scope\": \"global\", \"descriptor_name\": \"foreign_exchange-vanilla-options\" }  Response: {    \"data\": {        \"uid\": \"ac49453d-cc9c-11ec-8bac-5314d58ea570\",        \"descriptor_name\": \"fx_forward\"    } }  Error response:  Push to non ‘global’ scope : {    \"error\": {        \"code\": 70,        \"message\": \"Invalid argument: only support 'global' scope\"    } }  Unauthorized user : {    \"error\": {        \"code\": 70,        \"message\": \"Invalid auth token - only operator is allowed to add validation rules\"    } }  Missing argument : {    \"error\": {        \"code\": 70,        \"message\": \"Missing argument: descriptor_name\"    } }  Invalid rule definition - rule col mismatch with descriptor : {    \"error\": {        \"code\": 70,        \"message\": \"Rule [fx_fwd] compile failed, details: Column [submission_clienttt] not found in schema [fx_forward]\"    } }  Invalid rule definition - RDL syntax error : {    \"error\": {        \"code\": 70,        \"message\": \"Rule [fx_fwd] compile failed, details: line 1:14 no viable alternative at input '[{\\\"$lower\\\":\\\"fx_forward.submission_service\\\"'\"    } }  Dependencies not found - dependencies could be: descriptor, named lut, custom function : {    \"error\": {        \"code\": 70,        \"message\": \"Rule [fx_fwd] compile failed, details: Invalid rule expression [ { \\\"$lut_name\\\" : \\\"tenor\\\", \\\"$exist\\\" : [\\\"fx_forward.submission_tenor\\\"] } ]\\n\\terr: com.peernova.api.searchmetadata.metadata.exceptions.MetadataNotFoundException: No Look Up Table by name [tenor] found in scope [global]\"    } }  Ruleset with same name already exist : {    \"error\": {        \"code\": 70,        \"message\": \"Validation rule for descriptor [fx_fwd] already exist\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_add_validation_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumValidationRuleDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumAcknowledgeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_add_validation_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_add_validation_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumAcknowledgeResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_disable_validation_rule(self, body, **kwargs):  # noqa: E501
        """DisableValidationRule method disables a validation rule in the system. The request includes the descriptor name and scope of the rule. Example of Request: { \"descriptor_name\" : \"foreign_exchange-vanilla-forwards\", \"scope\": \"global\" }  # noqa: E501

        Example of Response: {    \"data\": {        \"uid\": \"\",        \"descriptor_name\": \"foreign_exchange-vanilla-forwards\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_disable_validation_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumAcknowledgeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_disable_validation_rule_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_disable_validation_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """DisableValidationRule method disables a validation rule in the system. The request includes the descriptor name and scope of the rule. Example of Request: { \"descriptor_name\" : \"foreign_exchange-vanilla-forwards\", \"scope\": \"global\" }  # noqa: E501

        Example of Response: {    \"data\": {        \"uid\": \"\",        \"descriptor_name\": \"foreign_exchange-vanilla-forwards\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_disable_validation_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumAcknowledgeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_disable_validation_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_disable_validation_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumAcknowledgeResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_enable_validation_rule(self, body, **kwargs):  # noqa: E501
        """EnableValidationRule method enables a validation rule that has been previously disabled. The request includes the descriptor name and scope of the rule. Example of Request: { \"descriptor_name\" : \"foreign_exchange-vanilla-forwards\", \"scope\": \"global\" }  # noqa: E501

        Example of Response: {    \"data\": {        \"uid\": \"\",        \"descriptor_name\": \"foreign_exchange-vanilla-forwards\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_enable_validation_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumAcknowledgeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_enable_validation_rule_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_enable_validation_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """EnableValidationRule method enables a validation rule that has been previously disabled. The request includes the descriptor name and scope of the rule. Example of Request: { \"descriptor_name\" : \"foreign_exchange-vanilla-forwards\", \"scope\": \"global\" }  # noqa: E501

        Example of Response: {    \"data\": {        \"uid\": \"\",        \"descriptor_name\": \"foreign_exchange-vanilla-forwards\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_enable_validation_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumAcknowledgeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_enable_validation_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_enable_validation_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumAcknowledgeResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_get_generated_validation_rule(self, body, **kwargs):  # noqa: E501
        """GetGeneratedValidationRule method allows back office users to view all generated validation rulesets, including Java rulesets. Participant users can only view global generated validation rulesets and rulesets within their own scope. If no scope is given in the request, the default scope is used (\"global\" for operators and participant scope for the participant user). Authorization is fetched from the user's token. This method returns the latest version of the generated ruleset if multiple versions exist.  # noqa: E501

        Example of Request: {  \"descriptor_name\": \"foreign_exchange-vanilla-forwards\" }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_get_generated_validation_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumGetGeneratedValidationRuleResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_get_generated_validation_rule_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_get_generated_validation_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """GetGeneratedValidationRule method allows back office users to view all generated validation rulesets, including Java rulesets. Participant users can only view global generated validation rulesets and rulesets within their own scope. If no scope is given in the request, the default scope is used (\"global\" for operators and participant scope for the participant user). Authorization is fetched from the user's token. This method returns the latest version of the generated ruleset if multiple versions exist.  # noqa: E501

        Example of Request: {  \"descriptor_name\": \"foreign_exchange-vanilla-forwards\" }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_get_generated_validation_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumGetGeneratedValidationRuleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_get_generated_validation_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_get_generated_validation_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumGetGeneratedValidationRuleResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/generated', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_get_generated_validation_rule_version(self, descriptor_name, version_id, **kwargs):  # noqa: E501
        """GetGeneratedValidationRuleVersion method allows the user to view a particular version of a generated ruleset. The request requires a descriptor name and a version ID. If the requested ruleset version is not found, an error response is returned.  # noqa: E501

        Example of Request: GET /api/v1/validation/rule/generated/version/foreign_exchange-vanilla-forwards /QHF5uuOTjGprb3FRsI7ybBnU6-Ub32Xq8Q399PtQWeQ= {  \"scope\": \"global\" }  Example of Response: {     \"data\": {          \"versions\": [              {                 \"versionId\": \"teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=\",                 \"createdAt\": \"2022-05-04 16:20:58.0\"              },              {                  \"versionId\": \"mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=\",                  \"createdAt\": \"2022-05-04 16:17:19.0\"              },              {                  \"versionId\": \"6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=\",                  \"createdAt\": \"2022-05-04 15:02:00.0\"              }          ]      }  }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_get_generated_validation_rule_version(descriptor_name, version_id, async_req=True)
        >>> result = thread.get()

        :param descriptor_name: (required)
        :type descriptor_name: str
        :param version_id: (required)
        :type version_id: str
        :param name:
        :type name: str
        :param scope:
        :type scope: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumGetGeneratedValidationRuleResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_get_generated_validation_rule_version_with_http_info(descriptor_name, version_id, **kwargs)  # noqa: E501

    def validator_service_get_generated_validation_rule_version_with_http_info(self, descriptor_name, version_id, **kwargs):  # noqa: E501
        """GetGeneratedValidationRuleVersion method allows the user to view a particular version of a generated ruleset. The request requires a descriptor name and a version ID. If the requested ruleset version is not found, an error response is returned.  # noqa: E501

        Example of Request: GET /api/v1/validation/rule/generated/version/foreign_exchange-vanilla-forwards /QHF5uuOTjGprb3FRsI7ybBnU6-Ub32Xq8Q399PtQWeQ= {  \"scope\": \"global\" }  Example of Response: {     \"data\": {          \"versions\": [              {                 \"versionId\": \"teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=\",                 \"createdAt\": \"2022-05-04 16:20:58.0\"              },              {                  \"versionId\": \"mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=\",                  \"createdAt\": \"2022-05-04 16:17:19.0\"              },              {                  \"versionId\": \"6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=\",                  \"createdAt\": \"2022-05-04 15:02:00.0\"              }          ]      }  }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_get_generated_validation_rule_version_with_http_info(descriptor_name, version_id, async_req=True)
        >>> result = thread.get()

        :param descriptor_name: (required)
        :type descriptor_name: str
        :param version_id: (required)
        :type version_id: str
        :param name:
        :type name: str
        :param scope:
        :type scope: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumGetGeneratedValidationRuleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'descriptor_name',
            'version_id',
            'name',
            'scope'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_get_generated_validation_rule_version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'descriptor_name' is set
        if self.api_client.client_side_validation and local_var_params.get('descriptor_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `descriptor_name` when calling `validator_service_get_generated_validation_rule_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if self.api_client.client_side_validation and local_var_params.get('version_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `version_id` when calling `validator_service_get_generated_validation_rule_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'descriptor_name' in local_var_params:
            path_params['descriptorName'] = local_var_params['descriptor_name']  # noqa: E501
        if 'version_id' in local_var_params:
            path_params['versionId'] = local_var_params['version_id']  # noqa: E501

        query_params = []
        if local_var_params.get('name') is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if local_var_params.get('scope') is not None:  # noqa: E501
            query_params.append(('scope', local_var_params['scope']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumGetGeneratedValidationRuleResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/generated/version/{descriptorName}/{versionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_get_validation_rule(self, body, **kwargs):  # noqa: E501
        """GetValidationRule method retrieves information about a validation rule. Both back office users and participant users can view validation rulesets. The default scope is used if no scope is given in the request. Authorization is fetched from the user's token. The rule can be retrieved by either descriptor name or UID. If multiple versions of the rule exist, this method returns the latest version.  # noqa: E501

        Example of Request: {  \"descriptor_name\": \"fx_fwd\" }   Or: {  \"uid\": \"ac49453d-cc9c-11ec-8bac-5314d58ea570\" }    Example of Response: {    \"data\": {        \"uid\": \"\",        \"definition\": {            \"descriptorName\": \"foreign_exchange-vanilla-options\",            \"criteria\": [                {                    \"name\": \"FX-V-FXO: Option Instrument Parameter: Forward Points\",                    \"description\": \"This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \\\"Forward Points\\\".\",                    \"rule\": \"[\\\"foreign_exchange-vanilla-options.option_instrument_parameter\\\",\\\"$eq_case_insensitive\\\",\\\"Forward Points\\\"]\",                    \"tags\": [                        \"forward points\"                    ],                    \"metadata\": [],                    \"validations\": [                        {                            \"name\": \"FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check\",                            \"description\": \"Compare the fwrd_conversion_factor for a given underlying against the expected values.\",                            \"rule\": \"[ { \\\"$lut_name\\\": \\\"conversion_factor\\\", \\\"$get\\\": [ \\\"foreign_exchange-vanilla-options.underlying\\\" ] }, \\\"$eq\\\", \\\"foreign_exchange-vanilla-options.fwrd_conversion_factor\\\" ]\",                            \"ruleType\": \"INPUT_DATA\",                            \"severity\": 1,                            \"tags\": [],                            \"error\": {                                \"message\": \"[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].\",                                \"messageArgs\": [                                    \"foreign_exchange-vanilla-options.fwrd_conversion_factor\",                                    \"foreign_exchange-vanilla-options.underlying\"                                ]                            },                            \"filter\": \"\"                        }                    ]                }            ]        },        \"scope\": \"global\",        \"descriptorName\": \"foreign_exchange-vanilla-options\"    } }  Example of Error response:  Missing argument: {    \"error\": {        \"code\": 70,        \"message\": \"Missing argument: need either descriptor name or uid to get validation rule\"    } }  Resource not found : {    \"error\": {        \"code\": 70,        \"message\": \"Rule [fx_fwd] not found, details: [fx_fwd] of service [VALIDATIONRULESET] does not exist in namespace [global]\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_get_validation_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumGetValidationRuleResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_get_validation_rule_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_get_validation_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """GetValidationRule method retrieves information about a validation rule. Both back office users and participant users can view validation rulesets. The default scope is used if no scope is given in the request. Authorization is fetched from the user's token. The rule can be retrieved by either descriptor name or UID. If multiple versions of the rule exist, this method returns the latest version.  # noqa: E501

        Example of Request: {  \"descriptor_name\": \"fx_fwd\" }   Or: {  \"uid\": \"ac49453d-cc9c-11ec-8bac-5314d58ea570\" }    Example of Response: {    \"data\": {        \"uid\": \"\",        \"definition\": {            \"descriptorName\": \"foreign_exchange-vanilla-options\",            \"criteria\": [                {                    \"name\": \"FX-V-FXO: Option Instrument Parameter: Forward Points\",                    \"description\": \"This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \\\"Forward Points\\\".\",                    \"rule\": \"[\\\"foreign_exchange-vanilla-options.option_instrument_parameter\\\",\\\"$eq_case_insensitive\\\",\\\"Forward Points\\\"]\",                    \"tags\": [                        \"forward points\"                    ],                    \"metadata\": [],                    \"validations\": [                        {                            \"name\": \"FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check\",                            \"description\": \"Compare the fwrd_conversion_factor for a given underlying against the expected values.\",                            \"rule\": \"[ { \\\"$lut_name\\\": \\\"conversion_factor\\\", \\\"$get\\\": [ \\\"foreign_exchange-vanilla-options.underlying\\\" ] }, \\\"$eq\\\", \\\"foreign_exchange-vanilla-options.fwrd_conversion_factor\\\" ]\",                            \"ruleType\": \"INPUT_DATA\",                            \"severity\": 1,                            \"tags\": [],                            \"error\": {                                \"message\": \"[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].\",                                \"messageArgs\": [                                    \"foreign_exchange-vanilla-options.fwrd_conversion_factor\",                                    \"foreign_exchange-vanilla-options.underlying\"                                ]                            },                            \"filter\": \"\"                        }                    ]                }            ]        },        \"scope\": \"global\",        \"descriptorName\": \"foreign_exchange-vanilla-options\"    } }  Example of Error response:  Missing argument: {    \"error\": {        \"code\": 70,        \"message\": \"Missing argument: need either descriptor name or uid to get validation rule\"    } }  Resource not found : {    \"error\": {        \"code\": 70,        \"message\": \"Rule [fx_fwd] not found, details: [fx_fwd] of service [VALIDATIONRULESET] does not exist in namespace [global]\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_get_validation_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumGetValidationRuleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_get_validation_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_get_validation_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumGetValidationRuleResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_get_validation_rule_version(self, descriptor_name, version_id, **kwargs):  # noqa: E501
        """This is a method that allows both back office users and regular users to retrieve a specific version of a ruleset given the descriptor name and version ID. The ruleset is used for validation purposes and contains criteria and rules for validating data submissions. Back office users can retrieve a particular version of a ruleset from any scope, while participant users can only retrieve a version of a ruleset from either the global scope or their own scope.  # noqa: E501

        Example of Request: GET /api/v1/validation/rule/version/fx_fwd_May04/teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=  Example of Response: {    \"data\": {        \"uid\": \"\",        \"definition\": {            \"descriptorName\": \"foreign_exchange-vanilla-options\",            \"criteria\": [                {                    \"name\": \"FX-V-FXO: Option Instrument Parameter: Forward Points\",                    \"description\": \"This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \\\"Forward Points\\\".\",                    \"rule\": \"[\\\"foreign_exchange-vanilla-options.option_instrument_parameter\\\",\\\"$eq_case_insensitive\\\",\\\"Forward Points\\\"]\",                    \"tags\": [                        \"forward points\"                    ],                    \"metadata\": [],                    \"validations\": [                        {                            \"name\": \"FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check\",                            \"description\": \"Compare the fwrd_conversion_factor for a given underlying against the expected values.\",                            \"rule\": \"[ { \\\"$lut_name\\\": \\\"conversion_factor\\\", \\\"$get\\\": [ \\\"foreign_exchange-vanilla-options.underlying\\\" ] }, \\\"$eq\\\", \\\"foreign_exchange-vanilla-options.fwrd_conversion_factor\\\" ]\",                            \"ruleType\": \"INPUT_DATA\",                            \"severity\": 1,                            \"tags\": [],                            \"error\": {                                \"message\": \"[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].\",                                \"messageArgs\": [                                    \"foreign_exchange-vanilla-options.fwrd_conversion_factor\",                                    \"foreign_exchange-vanilla-options.underlying\"                                ]                            },                            \"filter\": \"\"                        }                    ]                }            ]        },        \"scope\": \"global\",        \"descriptorName\": \"foreign_exchange-vanilla-options\"    } }  Example of Error response: Resource not found: {    \"error\": {        \"code\": 70,        \"message\": \"Failed to get rule [fx_fwd_May04], details: MetaData entity not found: name [fx_fwd_May04] version: [teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk] in namespace: [global]\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_get_validation_rule_version(descriptor_name, version_id, async_req=True)
        >>> result = thread.get()

        :param descriptor_name: (required)
        :type descriptor_name: str
        :param version_id: (required)
        :type version_id: str
        :param name:
        :type name: str
        :param scope:
        :type scope: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumGetValidationRuleResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_get_validation_rule_version_with_http_info(descriptor_name, version_id, **kwargs)  # noqa: E501

    def validator_service_get_validation_rule_version_with_http_info(self, descriptor_name, version_id, **kwargs):  # noqa: E501
        """This is a method that allows both back office users and regular users to retrieve a specific version of a ruleset given the descriptor name and version ID. The ruleset is used for validation purposes and contains criteria and rules for validating data submissions. Back office users can retrieve a particular version of a ruleset from any scope, while participant users can only retrieve a version of a ruleset from either the global scope or their own scope.  # noqa: E501

        Example of Request: GET /api/v1/validation/rule/version/fx_fwd_May04/teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=  Example of Response: {    \"data\": {        \"uid\": \"\",        \"definition\": {            \"descriptorName\": \"foreign_exchange-vanilla-options\",            \"criteria\": [                {                    \"name\": \"FX-V-FXO: Option Instrument Parameter: Forward Points\",                    \"description\": \"This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \\\"Forward Points\\\".\",                    \"rule\": \"[\\\"foreign_exchange-vanilla-options.option_instrument_parameter\\\",\\\"$eq_case_insensitive\\\",\\\"Forward Points\\\"]\",                    \"tags\": [                        \"forward points\"                    ],                    \"metadata\": [],                    \"validations\": [                        {                            \"name\": \"FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check\",                            \"description\": \"Compare the fwrd_conversion_factor for a given underlying against the expected values.\",                            \"rule\": \"[ { \\\"$lut_name\\\": \\\"conversion_factor\\\", \\\"$get\\\": [ \\\"foreign_exchange-vanilla-options.underlying\\\" ] }, \\\"$eq\\\", \\\"foreign_exchange-vanilla-options.fwrd_conversion_factor\\\" ]\",                            \"ruleType\": \"INPUT_DATA\",                            \"severity\": 1,                            \"tags\": [],                            \"error\": {                                \"message\": \"[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].\",                                \"messageArgs\": [                                    \"foreign_exchange-vanilla-options.fwrd_conversion_factor\",                                    \"foreign_exchange-vanilla-options.underlying\"                                ]                            },                            \"filter\": \"\"                        }                    ]                }            ]        },        \"scope\": \"global\",        \"descriptorName\": \"foreign_exchange-vanilla-options\"    } }  Example of Error response: Resource not found: {    \"error\": {        \"code\": 70,        \"message\": \"Failed to get rule [fx_fwd_May04], details: MetaData entity not found: name [fx_fwd_May04] version: [teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk] in namespace: [global]\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_get_validation_rule_version_with_http_info(descriptor_name, version_id, async_req=True)
        >>> result = thread.get()

        :param descriptor_name: (required)
        :type descriptor_name: str
        :param version_id: (required)
        :type version_id: str
        :param name:
        :type name: str
        :param scope:
        :type scope: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumGetValidationRuleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'descriptor_name',
            'version_id',
            'name',
            'scope'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_get_validation_rule_version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'descriptor_name' is set
        if self.api_client.client_side_validation and local_var_params.get('descriptor_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `descriptor_name` when calling `validator_service_get_validation_rule_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if self.api_client.client_side_validation and local_var_params.get('version_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `version_id` when calling `validator_service_get_validation_rule_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'descriptor_name' in local_var_params:
            path_params['descriptorName'] = local_var_params['descriptor_name']  # noqa: E501
        if 'version_id' in local_var_params:
            path_params['versionId'] = local_var_params['version_id']  # noqa: E501

        query_params = []
        if local_var_params.get('name') is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if local_var_params.get('scope') is not None:  # noqa: E501
            query_params.append(('scope', local_var_params['scope']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumGetValidationRuleResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/version/{descriptorName}/{versionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_list_generated_validation_rule_versions(self, body, **kwargs):  # noqa: E501
        """ListGeneratedValidationRuleVersions method returns a list of generated ruleset version IDs along with their creation timestamps. The request requires a descriptor name. If the requested ruleset is not found, an error response is returned.  # noqa: E501

        Example of Request: {  \"descriptor_name\": \"fx_fwd\" }   Example of Response: {    \"data\": {        \"versions\": [            {                \"versionId\": \"teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=\",                \"createdAt\": \"2022-05-04 16:20:58.0\"            },            {                \"versionId\": \"mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=\",                \"createdAt\": \"2022-05-04 16:17:19.0\"            },            {                \"versionId\": \"6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=\",                \"createdAt\": \"2022-05-04 15:02:00.0\"            }        ]    } }  Example of Error response: Resource not found: {    \"error\": {        \"code\": 70,        \"message\": \"Failed to get rule [fx_fwd] versions, details: Rule [fx_fwd] not found\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_list_generated_validation_rule_versions(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumListVersionResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_list_generated_validation_rule_versions_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_list_generated_validation_rule_versions_with_http_info(self, body, **kwargs):  # noqa: E501
        """ListGeneratedValidationRuleVersions method returns a list of generated ruleset version IDs along with their creation timestamps. The request requires a descriptor name. If the requested ruleset is not found, an error response is returned.  # noqa: E501

        Example of Request: {  \"descriptor_name\": \"fx_fwd\" }   Example of Response: {    \"data\": {        \"versions\": [            {                \"versionId\": \"teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=\",                \"createdAt\": \"2022-05-04 16:20:58.0\"            },            {                \"versionId\": \"mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=\",                \"createdAt\": \"2022-05-04 16:17:19.0\"            },            {                \"versionId\": \"6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=\",                \"createdAt\": \"2022-05-04 15:02:00.0\"            }        ]    } }  Example of Error response: Resource not found: {    \"error\": {        \"code\": 70,        \"message\": \"Failed to get rule [fx_fwd] versions, details: Rule [fx_fwd] not found\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_list_generated_validation_rule_versions_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumListVersionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_list_generated_validation_rule_versions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_list_generated_validation_rule_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumListVersionResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/generated/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_list_validation_rule_versions(self, body, **kwargs):  # noqa: E501
        """ListValidationRuleVersions method is used to retrieve a list of versions for a given validation rule. Both back office users and participant users can retrieve versions of validation rulesets, but the scope will depend on the user. The request must specify the descriptor name for the validation rule. The response will include a list of versions and their created timestamp. If the requested rule is not found, an error response will be returned.  # noqa: E501

        Example of Request: {  \"descriptor_name\": \"fx_fwd\" }  Example of Response: {    \"data\": {        \"versions\": [            {                \"versionId\": \"teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=\",                \"createdAt\": \"2022-05-04 16:20:58.0\"            },            {                \"versionId\": \"mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=\",                \"createdAt\": \"2022-05-04 16:17:19.0\"            },            {                \"versionId\": \"6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=\",                \"createdAt\": \"2022-05-04 15:02:00.0\"            }        ]    } }  Example of Error response: Resource not found: {    \"error\": {        \"code\": 70,        \"message\": \"Failed to get rule [fx_fwd] versions, details: Rule [fx_fwd_validation] not found\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_list_validation_rule_versions(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumListVersionResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_list_validation_rule_versions_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_list_validation_rule_versions_with_http_info(self, body, **kwargs):  # noqa: E501
        """ListValidationRuleVersions method is used to retrieve a list of versions for a given validation rule. Both back office users and participant users can retrieve versions of validation rulesets, but the scope will depend on the user. The request must specify the descriptor name for the validation rule. The response will include a list of versions and their created timestamp. If the requested rule is not found, an error response will be returned.  # noqa: E501

        Example of Request: {  \"descriptor_name\": \"fx_fwd\" }  Example of Response: {    \"data\": {        \"versions\": [            {                \"versionId\": \"teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=\",                \"createdAt\": \"2022-05-04 16:20:58.0\"            },            {                \"versionId\": \"mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=\",                \"createdAt\": \"2022-05-04 16:17:19.0\"            },            {                \"versionId\": \"6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=\",                \"createdAt\": \"2022-05-04 15:02:00.0\"            }        ]    } }  Example of Error response: Resource not found: {    \"error\": {        \"code\": 70,        \"message\": \"Failed to get rule [fx_fwd] versions, details: Rule [fx_fwd_validation] not found\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_list_validation_rule_versions_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumListVersionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_list_validation_rule_versions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_list_validation_rule_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumListVersionResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_list_validation_rules(self, body, **kwargs):  # noqa: E501
        """ListValidationRules method is used to retrieve a list of validation rule names. Both back office users and participant users can retrieve validation rulesets, but the scope and authorization will depend on the user. The default scope is used if no scope is specified in the request. The request may include an optional filter and orderBy parameter to refine the search results. Pagination is also supported. The response will include a list of rule names matching the filter criteria.  # noqa: E501

        Example of Request: {  \"scope\": \"global\",  \"filter\": \".*exchange.*\",  \"orderBy\": {   \"order\": \"DESC\"  } }  Example of Response: {    \"data\": {        \"results\": [            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-vanilla-options\"            },            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-vanilla-forwards\"            },            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-exotics-tarfs\"            }        ]    } }  Example of Request with pagination: {  \"scope\": \"global\",  \"filter\": \".*exchange.*\",  \"orderBy\": {   \"order\": \"DESC\"  },  \"limit\": {   \"value\": 2  },  \"offset\": 1 }  Example of Response: {    \"data\": {        \"results\": [            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-vanilla-forwards\"            },            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-exotics-tarfs\"            }        ]    } }  Example of Error response: not ‘global’ scope: {    \"error\": {        \"code\": 70,        \"message\": \"Invalid argument: only support 'global' scope\"    } }  Invalid filter/regex: {    \"error\": {        \"code\": 70,        \"message\": \"Failed to list rules: Dangling meta character '*' near index 0\\n*May*\\n^\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_list_validation_rules(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumListRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumListRuleResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_list_validation_rules_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_list_validation_rules_with_http_info(self, body, **kwargs):  # noqa: E501
        """ListValidationRules method is used to retrieve a list of validation rule names. Both back office users and participant users can retrieve validation rulesets, but the scope and authorization will depend on the user. The default scope is used if no scope is specified in the request. The request may include an optional filter and orderBy parameter to refine the search results. Pagination is also supported. The response will include a list of rule names matching the filter criteria.  # noqa: E501

        Example of Request: {  \"scope\": \"global\",  \"filter\": \".*exchange.*\",  \"orderBy\": {   \"order\": \"DESC\"  } }  Example of Response: {    \"data\": {        \"results\": [            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-vanilla-options\"            },            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-vanilla-forwards\"            },            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-exotics-tarfs\"            }        ]    } }  Example of Request with pagination: {  \"scope\": \"global\",  \"filter\": \".*exchange.*\",  \"orderBy\": {   \"order\": \"DESC\"  },  \"limit\": {   \"value\": 2  },  \"offset\": 1 }  Example of Response: {    \"data\": {        \"results\": [            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-vanilla-forwards\"            },            {                \"uid\": \"\",                \"descriptor_name\": \"foreign_exchange-exotics-tarfs\"            }        ]    } }  Example of Error response: not ‘global’ scope: {    \"error\": {        \"code\": 70,        \"message\": \"Invalid argument: only support 'global' scope\"    } }  Invalid filter/regex: {    \"error\": {        \"code\": 70,        \"message\": \"Failed to list rules: Dangling meta character '*' near index 0\\n*May*\\n^\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_list_validation_rules_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumListRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumListRuleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_list_validation_rules" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_list_validation_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumListRuleResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validator_service_rdl_check(self, body, **kwargs):  # noqa: E501
        """RdlCheck method checks the syntax of a given RDL (Rule Description Language) expression. It takes a RdlCheckRequest message as input and returns a MessageResponse message.  # noqa: E501

        Example of Request: {  \"rdl\": \"[\\\"a\\\", \\\"$eq\\\", \\\"b\\\"\" }  Example of Response: {    \"data\": {        \"message\": \"success\"    } }  Example of Error response: Resource not found: {    \"error\": {        \"code\": 69,        \"message\": \"rdl [[\\\"a\\\", \\\"$eq\\\", \\\"b\\\"] cannot be parsed. Error: line 1:16 missing ']' at '<EOF>'\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_rdl_check(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumRdlCheckRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumMessageResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.validator_service_rdl_check_with_http_info(body, **kwargs)  # noqa: E501

    def validator_service_rdl_check_with_http_info(self, body, **kwargs):  # noqa: E501
        """RdlCheck method checks the syntax of a given RDL (Rule Description Language) expression. It takes a RdlCheckRequest message as input and returns a MessageResponse message.  # noqa: E501

        Example of Request: {  \"rdl\": \"[\\\"a\\\", \\\"$eq\\\", \\\"b\\\"\" }  Example of Response: {    \"data\": {        \"message\": \"success\"    } }  Example of Error response: Resource not found: {    \"error\": {        \"code\": 69,        \"message\": \"rdl [[\\\"a\\\", \\\"$eq\\\", \\\"b\\\"] cannot be parsed. Error: line 1:16 missing ']' at '<EOF>'\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validator_service_rdl_check_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumRdlCheckRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumMessageResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validator_service_rdl_check" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validator_service_rdl_check`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumMessageResponse",
        }

        return self.api_client.call_api(
            '/api/v1/validation/rule/check', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
