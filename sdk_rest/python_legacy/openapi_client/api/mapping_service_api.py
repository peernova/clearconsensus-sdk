# coding: utf-8

"""
    clearconsensus-sdk

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class MappingServiceApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def mapping_service_add_mapping_rule(self, body, **kwargs):  # noqa: E501
        """AddMappingRule AddMappingRule is an API used to add a specific mapping rule to the system. The name provided for the mapping rule must match the asset class and descriptor names. If a mapping rule with the same name already exists, it will be updated. This API accepts a MappingRuleDefinition object as its parameter,which includes information about the mapping rule being added. The response from this API is a DescriptorPairBasedAcknowledgeResponse,which acknowledges the addition of the mapping rule.  # noqa: E501

        Example of request for regular user : {   \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"transformations\":[      {         \"targetColumn\":\"submission_date\",         \"sourceColumn\":\"date\"      },      {         \"targetColumn\":\"submission_asset\",         \"rule\":\"{ \\\"$to_upper\\\": { \\\"$trim\\\" : \\\"fx_test_for_bank1.submission_asset\\\" }}\",         \"name\": \"upper case asset\",         \"description\": \"i am optional...\"      }   ] }  Example of request for Back Office : {   \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"scope\":\"global\",   \"transformations\":[      {         \"targetColumn\":\"submission_date\",         \"sourceColumn\":\"another_date\"      },      {         \"targetColumn\":\"submission_asset\",         \"rule\":\"{ \\\"$to_upper\\\": { \\\"$trim\\\" : \\\"fx_test_for_bank1.submission_asset\\\" }}\",         \"name\": \"upper case asset\",         \"description\": \"i am optional...\"      }   ] }  Example of response : {   \"data\":{      \"uid\":\"fc8b57b7-cc90-11ec-b784-8dfc726b351f\",      \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",      \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\"   } }  Example of error response : {   \"error\":{      \"code\":70,      \"message\":\"Missing argument: rule name.\"   } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_add_mapping_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumMappingRuleDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumDescriptorPairBasedAcknowledgeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.mapping_service_add_mapping_rule_with_http_info(body, **kwargs)  # noqa: E501

    def mapping_service_add_mapping_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """AddMappingRule AddMappingRule is an API used to add a specific mapping rule to the system. The name provided for the mapping rule must match the asset class and descriptor names. If a mapping rule with the same name already exists, it will be updated. This API accepts a MappingRuleDefinition object as its parameter,which includes information about the mapping rule being added. The response from this API is a DescriptorPairBasedAcknowledgeResponse,which acknowledges the addition of the mapping rule.  # noqa: E501

        Example of request for regular user : {   \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"transformations\":[      {         \"targetColumn\":\"submission_date\",         \"sourceColumn\":\"date\"      },      {         \"targetColumn\":\"submission_asset\",         \"rule\":\"{ \\\"$to_upper\\\": { \\\"$trim\\\" : \\\"fx_test_for_bank1.submission_asset\\\" }}\",         \"name\": \"upper case asset\",         \"description\": \"i am optional...\"      }   ] }  Example of request for Back Office : {   \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"scope\":\"global\",   \"transformations\":[      {         \"targetColumn\":\"submission_date\",         \"sourceColumn\":\"another_date\"      },      {         \"targetColumn\":\"submission_asset\",         \"rule\":\"{ \\\"$to_upper\\\": { \\\"$trim\\\" : \\\"fx_test_for_bank1.submission_asset\\\" }}\",         \"name\": \"upper case asset\",         \"description\": \"i am optional...\"      }   ] }  Example of response : {   \"data\":{      \"uid\":\"fc8b57b7-cc90-11ec-b784-8dfc726b351f\",      \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",      \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\"   } }  Example of error response : {   \"error\":{      \"code\":70,      \"message\":\"Missing argument: rule name.\"   } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_add_mapping_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumMappingRuleDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumDescriptorPairBasedAcknowledgeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mapping_service_add_mapping_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `mapping_service_add_mapping_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumDescriptorPairBasedAcknowledgeResponse",
        }

        return self.api_client.call_api(
            '/api/v1/mapping/rule/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def mapping_service_disable_mapping_rule(self, body, **kwargs):  # noqa: E501
        """DisableMappingRule is used to disable a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedGetDefinition object as its parameter, which specifies the source and destination descriptors for the mapping rule. The response from this it is a DescriptorPairBasedAcknowledgeResponse, which acknowledges the disablement of the mapping rule.  # noqa: E501

        Request: {  \"src_descriptor\":\"foreign_exchange-vanilla-options\",  \"dest_descriptor\":\"foreign_exchange-vanilla-options\"  \"scope\": \"Zbank1\" }  Response: {    \"data\": {        \"uid\": \"\",        \"src_descriptor\":\"foreign_exchange-vanilla-options\",        \"dest_descriptor\":\"foreign_exchange-vanilla-options\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_disable_mapping_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumDescriptorPairBasedGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumDescriptorPairBasedAcknowledgeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.mapping_service_disable_mapping_rule_with_http_info(body, **kwargs)  # noqa: E501

    def mapping_service_disable_mapping_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """DisableMappingRule is used to disable a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedGetDefinition object as its parameter, which specifies the source and destination descriptors for the mapping rule. The response from this it is a DescriptorPairBasedAcknowledgeResponse, which acknowledges the disablement of the mapping rule.  # noqa: E501

        Request: {  \"src_descriptor\":\"foreign_exchange-vanilla-options\",  \"dest_descriptor\":\"foreign_exchange-vanilla-options\"  \"scope\": \"Zbank1\" }  Response: {    \"data\": {        \"uid\": \"\",        \"src_descriptor\":\"foreign_exchange-vanilla-options\",        \"dest_descriptor\":\"foreign_exchange-vanilla-options\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_disable_mapping_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumDescriptorPairBasedGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumDescriptorPairBasedAcknowledgeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mapping_service_disable_mapping_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `mapping_service_disable_mapping_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumDescriptorPairBasedAcknowledgeResponse",
        }

        return self.api_client.call_api(
            '/api/v1/mapping/rule/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def mapping_service_enable_mapping_rule(self, body, **kwargs):  # noqa: E501
        """EnableMappingRule is used to enable a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedGetDefinition object as its parameter, which specifies the source and destination descriptors for the mapping rule. The response from this it is a DescriptorPairBasedAcknowledgeResponse, which acknowledges the enablement of the mapping rule.  # noqa: E501

        Request: {  \"src_descriptor\":\"foreign_exchange-vanilla-options\",  \"dest_descriptor\":\"foreign_exchange-vanilla-options\"  \"scope\": \"Zbank1\" }  Response: {    \"data\": {        \"uid\": \"\",        \"src_descriptor\":\"foreign_exchange-vanilla-options\",        \"dest_descriptor\":\"foreign_exchange-vanilla-options\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_enable_mapping_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumDescriptorPairBasedGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumDescriptorPairBasedAcknowledgeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.mapping_service_enable_mapping_rule_with_http_info(body, **kwargs)  # noqa: E501

    def mapping_service_enable_mapping_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """EnableMappingRule is used to enable a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedGetDefinition object as its parameter, which specifies the source and destination descriptors for the mapping rule. The response from this it is a DescriptorPairBasedAcknowledgeResponse, which acknowledges the enablement of the mapping rule.  # noqa: E501

        Request: {  \"src_descriptor\":\"foreign_exchange-vanilla-options\",  \"dest_descriptor\":\"foreign_exchange-vanilla-options\"  \"scope\": \"Zbank1\" }  Response: {    \"data\": {        \"uid\": \"\",        \"src_descriptor\":\"foreign_exchange-vanilla-options\",        \"dest_descriptor\":\"foreign_exchange-vanilla-options\"    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_enable_mapping_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumDescriptorPairBasedGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumDescriptorPairBasedAcknowledgeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mapping_service_enable_mapping_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `mapping_service_enable_mapping_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumDescriptorPairBasedAcknowledgeResponse",
        }

        return self.api_client.call_api(
            '/api/v1/mapping/rule/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def mapping_service_get_mapping_rule(self, body, **kwargs):  # noqa: E501
        """GetMappingRule is used to retrieve a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedGetDefinition object as its parameter, which specifies the source and destination descriptors for the mapping rule. The response from this it is a MappingRuleResponse, which includes information about the retrieved mapping rule.  # noqa: E501

        Example of request for regular user : {   \"identifier\":{      \"uid\":\"fc8b57b7-cc90-11ec-b784-8dfc726b351f\"   } } Or : {      \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",      \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\" }  Example of request for Back Office : {   \"identifier\":{       \"uid\":\"fc8b57b7-cc90-11ec-b784-8dfc726b351f\"   },   \"scope\":\"bank1\" } Or : {   \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"scope\":\"bank1\" }  Example of response : { \"data\": {  \"uid\": \"\",  \"srcDescriptor\": \"foreign_exchange-vanilla-options\",  \"destDescriptor\": \"foreign_exchange-vanilla-options\",  \"transformations\": [   {    \"name\": \"\",    \"targetColumn\": \"snap_date\",    \"sourceColumn\": \"submission_date\",    \"rule\": \"\",    \"description\": \"\"   }  ],  \"scope\": \"\" } }  Example of error response : {   \"error\":{      \"code\":70,      \"message\":\"Can't get mapping rule: [[empty] of service [MAPPINGRULESET] does not exist in namespace [bank1]].\"   } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_get_mapping_rule(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumDescriptorPairBasedGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumMappingRuleResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.mapping_service_get_mapping_rule_with_http_info(body, **kwargs)  # noqa: E501

    def mapping_service_get_mapping_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """GetMappingRule is used to retrieve a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedGetDefinition object as its parameter, which specifies the source and destination descriptors for the mapping rule. The response from this it is a MappingRuleResponse, which includes information about the retrieved mapping rule.  # noqa: E501

        Example of request for regular user : {   \"identifier\":{      \"uid\":\"fc8b57b7-cc90-11ec-b784-8dfc726b351f\"   } } Or : {      \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",      \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\" }  Example of request for Back Office : {   \"identifier\":{       \"uid\":\"fc8b57b7-cc90-11ec-b784-8dfc726b351f\"   },   \"scope\":\"bank1\" } Or : {   \"src_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"dest_descriptor\":\"foreign_exchange-vanilla-forwards\",   \"scope\":\"bank1\" }  Example of response : { \"data\": {  \"uid\": \"\",  \"srcDescriptor\": \"foreign_exchange-vanilla-options\",  \"destDescriptor\": \"foreign_exchange-vanilla-options\",  \"transformations\": [   {    \"name\": \"\",    \"targetColumn\": \"snap_date\",    \"sourceColumn\": \"submission_date\",    \"rule\": \"\",    \"description\": \"\"   }  ],  \"scope\": \"\" } }  Example of error response : {   \"error\":{      \"code\":70,      \"message\":\"Can't get mapping rule: [[empty] of service [MAPPINGRULESET] does not exist in namespace [bank1]].\"   } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_get_mapping_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumDescriptorPairBasedGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumMappingRuleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mapping_service_get_mapping_rule" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `mapping_service_get_mapping_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumMappingRuleResponse",
        }

        return self.api_client.call_api(
            '/api/v1/mapping/rule/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def mapping_service_get_mapping_rule_version(self, scope, src_descriptor, dest_descriptor, version_id, **kwargs):  # noqa: E501
        """GetMappingRuleVersion is used to retrieve a specific version of a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedVersionRequest object as its parameter, which includes the scope, source descriptor, destination descriptor, and version ID for the mapping rule. The response from it is a MappingRuleResponse, which includes information about the retrieved version of the mapping rule.  # noqa: E501

        Example of request : GET /api/v1/validation/rule/version/fx_fwd_1/fx_fwd_2/teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=  Example of response : {   \"definition\":\"{\\\"src_descriptor\\\":\\\"foreign_exchange-vanilla-forwards\\\",\\\"dest_descriptor\\\":\\\"foreign_exchange-vanilla-forwards\\\",\\\"transformations\\\":[{\\\"targetColumnName\\\":\\\"submission_date\\\",\\\"sourceColumnName\\\":\\\"another_date\\\"},{\\\"rule\\\":\\\"{ \\\\\\\"$to_upper\\\\\\\": { \\\\\\\"$trim\\\\\\\" : \\\\\\\"fx_test_for_bank1.submission_asset\\\\\\\" }}\\\",\\\"targetColumnName\\\":\\\"submission_asset\\\", \\\"name\\\": \\\"upper case asset\\\", \\\"description\\\": \\\"i am optional...\\\"}]}\" }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_get_mapping_rule_version(scope, src_descriptor, dest_descriptor, version_id, async_req=True)
        >>> result = thread.get()

        :param scope: (required)
        :type scope: str
        :param src_descriptor: (required)
        :type src_descriptor: str
        :param dest_descriptor: (required)
        :type dest_descriptor: str
        :param version_id: (required)
        :type version_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumMappingRuleResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.mapping_service_get_mapping_rule_version_with_http_info(scope, src_descriptor, dest_descriptor, version_id, **kwargs)  # noqa: E501

    def mapping_service_get_mapping_rule_version_with_http_info(self, scope, src_descriptor, dest_descriptor, version_id, **kwargs):  # noqa: E501
        """GetMappingRuleVersion is used to retrieve a specific version of a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedVersionRequest object as its parameter, which includes the scope, source descriptor, destination descriptor, and version ID for the mapping rule. The response from it is a MappingRuleResponse, which includes information about the retrieved version of the mapping rule.  # noqa: E501

        Example of request : GET /api/v1/validation/rule/version/fx_fwd_1/fx_fwd_2/teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=  Example of response : {   \"definition\":\"{\\\"src_descriptor\\\":\\\"foreign_exchange-vanilla-forwards\\\",\\\"dest_descriptor\\\":\\\"foreign_exchange-vanilla-forwards\\\",\\\"transformations\\\":[{\\\"targetColumnName\\\":\\\"submission_date\\\",\\\"sourceColumnName\\\":\\\"another_date\\\"},{\\\"rule\\\":\\\"{ \\\\\\\"$to_upper\\\\\\\": { \\\\\\\"$trim\\\\\\\" : \\\\\\\"fx_test_for_bank1.submission_asset\\\\\\\" }}\\\",\\\"targetColumnName\\\":\\\"submission_asset\\\", \\\"name\\\": \\\"upper case asset\\\", \\\"description\\\": \\\"i am optional...\\\"}]}\" }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_get_mapping_rule_version_with_http_info(scope, src_descriptor, dest_descriptor, version_id, async_req=True)
        >>> result = thread.get()

        :param scope: (required)
        :type scope: str
        :param src_descriptor: (required)
        :type src_descriptor: str
        :param dest_descriptor: (required)
        :type dest_descriptor: str
        :param version_id: (required)
        :type version_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumMappingRuleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'scope',
            'src_descriptor',
            'dest_descriptor',
            'version_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mapping_service_get_mapping_rule_version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scope' is set
        if self.api_client.client_side_validation and local_var_params.get('scope') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `scope` when calling `mapping_service_get_mapping_rule_version`")  # noqa: E501
        # verify the required parameter 'src_descriptor' is set
        if self.api_client.client_side_validation and local_var_params.get('src_descriptor') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `src_descriptor` when calling `mapping_service_get_mapping_rule_version`")  # noqa: E501
        # verify the required parameter 'dest_descriptor' is set
        if self.api_client.client_side_validation and local_var_params.get('dest_descriptor') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dest_descriptor` when calling `mapping_service_get_mapping_rule_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if self.api_client.client_side_validation and local_var_params.get('version_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `version_id` when calling `mapping_service_get_mapping_rule_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scope' in local_var_params:
            path_params['scope'] = local_var_params['scope']  # noqa: E501
        if 'src_descriptor' in local_var_params:
            path_params['srcDescriptor'] = local_var_params['src_descriptor']  # noqa: E501
        if 'dest_descriptor' in local_var_params:
            path_params['destDescriptor'] = local_var_params['dest_descriptor']  # noqa: E501
        if 'version_id' in local_var_params:
            path_params['versionId'] = local_var_params['version_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumMappingRuleResponse",
        }

        return self.api_client.call_api(
            '/api/v1/mapping/rule/version/{scope}/{srcDescriptor}/{destDescriptor}/{versionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def mapping_service_list_mapping_rule_versions(self, body, **kwargs):  # noqa: E501
        """ListMappingRuleVersions is used to retrieve a list of all versions of a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedGetDefinition object as its parameter, which specifies the source and destination descriptors for the mapping rule. The response from this it is a ListVersionResponse, which includes information about all versions of the mapping rule.  # noqa: E501

        Example of request : {  \"scope\": \"global\",  \"src_descriptor\":\"foreign_exchange-vanilla-options\",  \"dest_descriptor\":\"foreign_exchange-vanilla-options\" }  Example of response : {   \"data\":{      \"versions\":[         {            \"versionId\":\"EKc9bpBGCbLJmBqOpP0FTqtNusxgZrgCheGXj_MTj7A=\",            \"createdAt\":\"2022-05-05 11:33:59.0\"         },         {            \"versionId\":\"JKLFLkhV3SC-fqO0L-WTswr5ttHLfnvF8rMlLnkafAc=\",            \"createdAt\":\"2022-05-05 11:32:42.0\"         }      ]   } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_list_mapping_rule_versions(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumDescriptorPairBasedGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumListVersionResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.mapping_service_list_mapping_rule_versions_with_http_info(body, **kwargs)  # noqa: E501

    def mapping_service_list_mapping_rule_versions_with_http_info(self, body, **kwargs):  # noqa: E501
        """ListMappingRuleVersions is used to retrieve a list of all versions of a mapping rule for a given descriptor pair. It accepts a DescriptorPairBasedGetDefinition object as its parameter, which specifies the source and destination descriptors for the mapping rule. The response from this it is a ListVersionResponse, which includes information about all versions of the mapping rule.  # noqa: E501

        Example of request : {  \"scope\": \"global\",  \"src_descriptor\":\"foreign_exchange-vanilla-options\",  \"dest_descriptor\":\"foreign_exchange-vanilla-options\" }  Example of response : {   \"data\":{      \"versions\":[         {            \"versionId\":\"EKc9bpBGCbLJmBqOpP0FTqtNusxgZrgCheGXj_MTj7A=\",            \"createdAt\":\"2022-05-05 11:33:59.0\"         },         {            \"versionId\":\"JKLFLkhV3SC-fqO0L-WTswr5ttHLfnvF8rMlLnkafAc=\",            \"createdAt\":\"2022-05-05 11:32:42.0\"         }      ]   } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_list_mapping_rule_versions_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumDescriptorPairBasedGetDefinition
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumListVersionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mapping_service_list_mapping_rule_versions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `mapping_service_list_mapping_rule_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumListVersionResponse",
        }

        return self.api_client.call_api(
            '/api/v1/mapping/rule/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def mapping_service_list_mapping_rules(self, body, **kwargs):  # noqa: E501
        """ListMappingRules is used to retrieve a list of all mapping rules in the system. It accepts a ListRequest object as its parameter, which includes optional parameters for filtering the results. The response from this it is a MappingRuleList, which includes information about all mapping rules in the system that match the provided filter parameters.  # noqa: E501

        Example of request : {   \"scope\":\"global\" } Or optionally use filter: {   \"scope\":\"global\",   \"filter\": \".*vanilla.*__.*vanilla.*\" // all mapping rules from any vanilla to any vanilla }  Example of response : {    \"data\": {        \"results\": [            {                \"uid\": \"Djqreg7gTs7CV2rSyyucOWCFjK7ldgS9yQX0o0rEiV0=\",                \"src_descriptor\": \"foreign_exchange-vanilla-forwards\",                \"dest_descriptor\": \"foreign_exchange-vanilla-forwards\"             },            {                \"uid\": \"Djqreg7gTs7CV2rSyyucOWCFjK7ldgS9yQX0o0rEiV0=\",                \"src_descriptor\": \"foreign_exchange-vanilla-options\",                \"dest_descriptor\": \"foreign_exchange-vanilla-options\"            }        ]    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_list_mapping_rules(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumListRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TitaniumMappingRuleList
        """
        kwargs['_return_http_data_only'] = True
        return self.mapping_service_list_mapping_rules_with_http_info(body, **kwargs)  # noqa: E501

    def mapping_service_list_mapping_rules_with_http_info(self, body, **kwargs):  # noqa: E501
        """ListMappingRules is used to retrieve a list of all mapping rules in the system. It accepts a ListRequest object as its parameter, which includes optional parameters for filtering the results. The response from this it is a MappingRuleList, which includes information about all mapping rules in the system that match the provided filter parameters.  # noqa: E501

        Example of request : {   \"scope\":\"global\" } Or optionally use filter: {   \"scope\":\"global\",   \"filter\": \".*vanilla.*__.*vanilla.*\" // all mapping rules from any vanilla to any vanilla }  Example of response : {    \"data\": {        \"results\": [            {                \"uid\": \"Djqreg7gTs7CV2rSyyucOWCFjK7ldgS9yQX0o0rEiV0=\",                \"src_descriptor\": \"foreign_exchange-vanilla-forwards\",                \"dest_descriptor\": \"foreign_exchange-vanilla-forwards\"             },            {                \"uid\": \"Djqreg7gTs7CV2rSyyucOWCFjK7ldgS9yQX0o0rEiV0=\",                \"src_descriptor\": \"foreign_exchange-vanilla-options\",                \"dest_descriptor\": \"foreign_exchange-vanilla-options\"            }        ]    } }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mapping_service_list_mapping_rules_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: TitaniumListRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TitaniumMappingRuleList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mapping_service_list_mapping_rules" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `mapping_service_list_mapping_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TitaniumMappingRuleList",
        }

        return self.api_client.call_api(
            '/api/v1/mapping/rule/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
