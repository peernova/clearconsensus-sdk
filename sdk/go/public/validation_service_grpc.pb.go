// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package public

import (
	context "context"
	common "github.com/peernova/clearconsensus-sdk/sdk/go/common"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ValidatorServiceClient is the client API for ValidatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ValidatorServiceClient interface {
	// AddValidationRule is a method used to add a validation rule to the system.
	// Backoffice users can create a new validation ruleset in the 'global' scope, for each asset class.
	// Participant users can create a new validation ruleset in its own scope, for each asset class.
	// Backoffice users can represent any participant and create a new validation ruleset in that participant's scope.
	// The default scope is used if no scope is given in the request ('global' for the operator, participant scope for that participant user).
	// The authorization will be fetched from the user's token. It will do an update if a validation rule with the same name already exists.
	//
	// Request for backoffice user:
	// {
	//
	//	"definition": {
	//	  "descriptor_name":"foreign_exchange-vanilla-options",
	//	  "criteria":[
	//	    {
	//	      "name":"FX-V-FXO: Option Instrument Parameter: Forward Points",
	//	      "description":"This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \"Forward Points\".",
	//	      "tags":[
	//	        "forward points"
	//	      ],
	//	      "metadata":[
	//
	//	      ],
	//	      "rule":"[\"foreign_exchange-vanilla-options.option_instrument_parameter\",\"$eq_case_insensitive\",\"Forward Points\"]",
	//	      "validations":[
	//	        {
	//	          "name":"FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check",
	//	          "severity":1,
	//	          "rule_type":"input_data",
	//	          "tags":[
	//
	//	          ],
	//	          "description":"Compare the fwrd_conversion_factor for a given underlying against the expected values.",
	//	          "rule":"[ { \"$lut_name\": \"conversion_factor\", \"$get\": [ \"foreign_exchange-vanilla-options.underlying\" ] }, \"$eq\", \"foreign_exchange-vanilla-options.fwrd_conversion_factor\" ]",
	//	          "error":{
	//	            "message":"[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].",
	//	            "message_args":[
	//	              "foreign_exchange-vanilla-options.fwrd_conversion_factor",
	//	              "foreign_exchange-vanilla-options.underlying"
	//	            ]
	//	          }
	//	        }
	//	      ]
	//	    }
	//	  ]
	//	},
	//
	// "scope": "global",
	// "descriptor_name": "foreign_exchange-vanilla-options"
	// }
	//
	// Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "ac49453d-cc9c-11ec-8bac-5314d58ea570",
	//	       "descriptor_name": "fx_forward"
	//	   }
	//	}
	//
	// Error response:
	//
	// Push to non ‘global’ scope :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Invalid argument: only support 'global' scope"
	//	   }
	//	}
	//
	// Unauthorized user :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Invalid auth token - only operator is allowed to add validation rules"
	//	   }
	//	}
	//
	// Missing argument :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Missing argument: descriptor_name"
	//	   }
	//	}
	//
	// Invalid rule definition - rule col mismatch with descriptor :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Rule [fx_fwd] compile failed, details: Column [submission_clienttt] not found in schema [fx_forward]"
	//	   }
	//	}
	//
	// Invalid rule definition - RDL syntax error :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Rule [fx_fwd] compile failed, details: line 1:14 no viable alternative at input '[{\"$lower\":\"fx_forward.submission_service\"'"
	//	   }
	//	}
	//
	// Dependencies not found - dependencies could be: descriptor, named lut, custom function :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Rule [fx_fwd] compile failed, details: Invalid rule expression [ { \"$lut_name\" : \"tenor\", \"$exist\" : [\"fx_forward.submission_tenor\"] } ]\n\terr: com.peernova.api.searchmetadata.metadata.exceptions.MetadataNotFoundException: No Look Up Table by name [tenor] found in scope [global]"
	//	   }
	//	}
	//
	// Ruleset with same name already exist :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Validation rule for descriptor [fx_fwd] already exist"
	//	   }
	//	}
	AddValidationRule(ctx context.Context, in *common.ValidationRuleDefinition, opts ...grpc.CallOption) (*common.AcknowledgeResponse, error)
	// GetValidationRule method retrieves information about a validation rule.
	// Both back office users and participant users can view validation rulesets.
	// The default scope is used if no scope is given in the request. Authorization is fetched from the user's token.
	// The rule can be retrieved by either descriptor name or UID.
	// If multiple versions of the rule exist, this method returns the latest version.
	//
	// Example of Request:
	//
	//	{
	//	 "descriptor_name": "fx_fwd"
	//	}
	//
	// Or:
	//
	//	{
	//	 "uid": "ac49453d-cc9c-11ec-8bac-5314d58ea570"
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "",
	//	       "definition": {
	//	           "descriptorName": "foreign_exchange-vanilla-options",
	//	           "criteria": [
	//	               {
	//	                   "name": "FX-V-FXO: Option Instrument Parameter: Forward Points",
	//	                   "description": "This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \"Forward Points\".",
	//	                   "rule": "[\"foreign_exchange-vanilla-options.option_instrument_parameter\",\"$eq_case_insensitive\",\"Forward Points\"]",
	//	                   "tags": [
	//	                       "forward points"
	//	                   ],
	//	                   "metadata": [],
	//	                   "validations": [
	//	                       {
	//	                           "name": "FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check",
	//	                           "description": "Compare the fwrd_conversion_factor for a given underlying against the expected values.",
	//	                           "rule": "[ { \"$lut_name\": \"conversion_factor\", \"$get\": [ \"foreign_exchange-vanilla-options.underlying\" ] }, \"$eq\", \"foreign_exchange-vanilla-options.fwrd_conversion_factor\" ]",
	//	                           "ruleType": "INPUT_DATA",
	//	                           "severity": 1,
	//	                           "tags": [],
	//	                           "error": {
	//	                               "message": "[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].",
	//	                               "messageArgs": [
	//	                                   "foreign_exchange-vanilla-options.fwrd_conversion_factor",
	//	                                   "foreign_exchange-vanilla-options.underlying"
	//	                               ]
	//	                           },
	//	                           "filter": ""
	//	                       }
	//	                   ]
	//	               }
	//	           ]
	//	       },
	//	       "scope": "global",
	//	       "descriptorName": "foreign_exchange-vanilla-options"
	//	   }
	//	}
	//
	// Example of Error response:
	//
	// Missing argument:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Missing argument: need either descriptor name or uid to get validation rule"
	//	   }
	//	}
	//
	// Resource not found :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Rule [fx_fwd] not found, details: [fx_fwd] of service [VALIDATIONRULESET] does not exist in namespace [global]"
	//	   }
	//	}
	GetValidationRule(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.GetValidationRuleResponse, error)
	// DisableValidationRule method disables a validation rule in the system.
	// The request includes the descriptor name and scope of the rule.
	// Example of Request:
	// {
	// "descriptor_name" : "foreign_exchange-vanilla-forwards",
	// "scope": "global"
	// }
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "",
	//	       "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	   }
	//	}
	DisableValidationRule(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.AcknowledgeResponse, error)
	// EnableValidationRule method enables a validation rule that has been previously disabled.
	// The request includes the descriptor name and scope of the rule.
	// Example of Request:
	// {
	// "descriptor_name" : "foreign_exchange-vanilla-forwards",
	// "scope": "global"
	// }
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "",
	//	       "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	   }
	//	}
	EnableValidationRule(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.AcknowledgeResponse, error)
	// ListValidationRules method is used to retrieve a list of validation rule names.
	// Both back office users and participant users can retrieve validation rulesets, but the scope and authorization will depend on the user.
	// The default scope is used if no scope is specified in the request.
	// The request may include an optional filter and orderBy parameter to refine the search results.
	// Pagination is also supported. The response will include a list of rule names matching the filter criteria.
	//
	// Example of Request:
	//
	//	{
	//	 "scope": "global",
	//	 "filter": ".*exchange.*",
	//	 "orderBy": {
	//	 	"order": "DESC"
	//	 }
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "results": [
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-vanilla-options"
	//	           },
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	           },
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-exotics-tarfs"
	//	           }
	//	       ]
	//	   }
	//	}
	//
	// Example of Request with pagination:
	//
	//	{
	//	 "scope": "global",
	//	 "filter": ".*exchange.*",
	//	 "orderBy": {
	//	 	"order": "DESC"
	//	 },
	//	 "limit": {
	//	 	"value": 2
	//	 },
	//	 "offset": 1
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "results": [
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	           },
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-exotics-tarfs"
	//	           }
	//	       ]
	//	   }
	//	}
	//
	// Example of Error response:
	// not ‘global’ scope:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Invalid argument: only support 'global' scope"
	//	   }
	//	}
	//
	// Invalid filter/regex:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Failed to list rules: Dangling meta character '*' near index 0\n*May*\n^"
	//	   }
	//	}
	ListValidationRules(ctx context.Context, in *common.ListRequest, opts ...grpc.CallOption) (*common.ListRuleResponse, error)
	// ListValidationRuleVersions method is used to retrieve a list of versions for a given validation rule.
	// Both back office users and participant users can retrieve versions of validation rulesets, but the scope will depend on the user.
	// The request must specify the descriptor name for the validation rule.
	// The response will include a list of versions and their created timestamp.
	// If the requested rule is not found, an error response will be returned.
	//
	// Example of Request:
	//
	//	{
	//	 "descriptor_name": "fx_fwd"
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "versions": [
	//	           {
	//	               "versionId": "teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=",
	//	               "createdAt": "2022-05-04 16:20:58.0"
	//	           },
	//	           {
	//	               "versionId": "mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=",
	//	               "createdAt": "2022-05-04 16:17:19.0"
	//	           },
	//	           {
	//	               "versionId": "6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=",
	//	               "createdAt": "2022-05-04 15:02:00.0"
	//	           }
	//	       ]
	//	   }
	//	}
	//
	// Example of Error response:
	// Resource not found:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Failed to get rule [fx_fwd] versions, details: Rule [fx_fwd_validation] not found"
	//	   }
	//	}
	ListValidationRuleVersions(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.ListVersionResponse, error)
	// This is a method that allows both back office users and regular users to retrieve a specific version of a ruleset given the descriptor name and version ID.
	// The ruleset is used for validation purposes and contains criteria and rules for validating data submissions.
	// Back office users can retrieve a particular version of a ruleset from any scope, while participant users can only retrieve a version of a ruleset from either the global scope or their own scope.
	//
	// Example of Request:
	// GET /api/v1/validation/rule/version/fx_fwd_May04/teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "",
	//	       "definition": {
	//	           "descriptorName": "foreign_exchange-vanilla-options",
	//	           "criteria": [
	//	               {
	//	                   "name": "FX-V-FXO: Option Instrument Parameter: Forward Points",
	//	                   "description": "This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \"Forward Points\".",
	//	                   "rule": "[\"foreign_exchange-vanilla-options.option_instrument_parameter\",\"$eq_case_insensitive\",\"Forward Points\"]",
	//	                   "tags": [
	//	                       "forward points"
	//	                   ],
	//	                   "metadata": [],
	//	                   "validations": [
	//	                       {
	//	                           "name": "FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check",
	//	                           "description": "Compare the fwrd_conversion_factor for a given underlying against the expected values.",
	//	                           "rule": "[ { \"$lut_name\": \"conversion_factor\", \"$get\": [ \"foreign_exchange-vanilla-options.underlying\" ] }, \"$eq\", \"foreign_exchange-vanilla-options.fwrd_conversion_factor\" ]",
	//	                           "ruleType": "INPUT_DATA",
	//	                           "severity": 1,
	//	                           "tags": [],
	//	                           "error": {
	//	                               "message": "[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].",
	//	                               "messageArgs": [
	//	                                   "foreign_exchange-vanilla-options.fwrd_conversion_factor",
	//	                                   "foreign_exchange-vanilla-options.underlying"
	//	                               ]
	//	                           },
	//	                           "filter": ""
	//	                       }
	//	                   ]
	//	               }
	//	           ]
	//	       },
	//	       "scope": "global",
	//	       "descriptorName": "foreign_exchange-vanilla-options"
	//	   }
	//	}
	//
	// Example of Error response:
	// Resource not found:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Failed to get rule [fx_fwd_May04], details: MetaData entity not found: name [fx_fwd_May04] version: [teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk] in namespace: [global]"
	//	   }
	//	}
	GetValidationRuleVersion(ctx context.Context, in *common.VersionRequest, opts ...grpc.CallOption) (*common.GetValidationRuleResponse, error)
	// GetGeneratedValidationRule method allows back office users to view all generated validation rulesets, including Java rulesets.
	// Participant users can only view global generated validation rulesets and rulesets within their own scope.
	// If no scope is given in the request, the default scope is used ("global" for operators and participant scope for the participant user).
	// Authorization is fetched from the user's token.
	// This method returns the latest version of the generated ruleset if multiple versions exist.
	//
	// Example of Request:
	//
	//	{
	//	 "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	}
	GetGeneratedValidationRule(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.GetGeneratedValidationRuleResponse, error)
	// ListGeneratedValidationRuleVersions method returns a list of generated ruleset version IDs along with their creation timestamps.
	// The request requires a descriptor name. If the requested ruleset is not found, an error response is returned.
	//
	// Example of Request:
	//
	//	{
	//	 "descriptor_name": "fx_fwd"
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "versions": [
	//	           {
	//	               "versionId": "teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=",
	//	               "createdAt": "2022-05-04 16:20:58.0"
	//	           },
	//	           {
	//	               "versionId": "mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=",
	//	               "createdAt": "2022-05-04 16:17:19.0"
	//	           },
	//	           {
	//	               "versionId": "6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=",
	//	               "createdAt": "2022-05-04 15:02:00.0"
	//	           }
	//	       ]
	//	   }
	//	}
	//
	// Example of Error response:
	// Resource not found:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Failed to get rule [fx_fwd] versions, details: Rule [fx_fwd] not found"
	//	   }
	//	}
	ListGeneratedValidationRuleVersions(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.ListVersionResponse, error)
	// GetGeneratedValidationRuleVersion method allows the user to view a particular version of a generated ruleset.
	// The request requires a descriptor name and a version ID.
	// If the requested ruleset version is not found, an error response is returned.
	//
	// Example of Request:
	// GET /api/v1/validation/rule/generated/version/foreign_exchange-vanilla-forwards
	// /QHF5uuOTjGprb3FRsI7ybBnU6-Ub32Xq8Q399PtQWeQ=
	//
	//	{
	//	 "scope": "global"
	//	}
	//
	// Example of Response:
	//
	//	{
	//	    "data": {
	//	         "versions": [
	//	             {
	//	                "versionId": "teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=",
	//	                "createdAt": "2022-05-04 16:20:58.0"
	//	             },
	//	             {
	//	                 "versionId": "mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=",
	//	                 "createdAt": "2022-05-04 16:17:19.0"
	//	             },
	//	             {
	//	                 "versionId": "6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=",
	//	                 "createdAt": "2022-05-04 15:02:00.0"
	//	             }
	//	         ]
	//	     }
	//	 }
	GetGeneratedValidationRuleVersion(ctx context.Context, in *common.VersionRequest, opts ...grpc.CallOption) (*common.GetGeneratedValidationRuleResponse, error)
	// RdlCheck method checks the syntax of a given RDL (Rule Description Language) expression.
	// It takes a RdlCheckRequest message as input and returns a MessageResponse message.
	//
	// Example of Request:
	//
	//	{
	//	 "rdl": "[\"a\", \"$eq\", \"b\""
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "message": "success"
	//	   }
	//	}
	//
	// Example of Error response:
	// Resource not found:
	//
	//	{
	//	   "error": {
	//	       "code": 69,
	//	       "message": "rdl [[\"a\", \"$eq\", \"b\"] cannot be parsed. Error: line 1:16 missing ']' at '<EOF>'"
	//	   }
	//	}
	RdlCheck(ctx context.Context, in *common.RdlCheckRequest, opts ...grpc.CallOption) (*common.MessageResponse, error)
}

type validatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewValidatorServiceClient(cc grpc.ClientConnInterface) ValidatorServiceClient {
	return &validatorServiceClient{cc}
}

func (c *validatorServiceClient) AddValidationRule(ctx context.Context, in *common.ValidationRuleDefinition, opts ...grpc.CallOption) (*common.AcknowledgeResponse, error) {
	out := new(common.AcknowledgeResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/AddValidationRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) GetValidationRule(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.GetValidationRuleResponse, error) {
	out := new(common.GetValidationRuleResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/GetValidationRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) DisableValidationRule(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.AcknowledgeResponse, error) {
	out := new(common.AcknowledgeResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/DisableValidationRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) EnableValidationRule(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.AcknowledgeResponse, error) {
	out := new(common.AcknowledgeResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/EnableValidationRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) ListValidationRules(ctx context.Context, in *common.ListRequest, opts ...grpc.CallOption) (*common.ListRuleResponse, error) {
	out := new(common.ListRuleResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/ListValidationRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) ListValidationRuleVersions(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.ListVersionResponse, error) {
	out := new(common.ListVersionResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/ListValidationRuleVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) GetValidationRuleVersion(ctx context.Context, in *common.VersionRequest, opts ...grpc.CallOption) (*common.GetValidationRuleResponse, error) {
	out := new(common.GetValidationRuleResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/GetValidationRuleVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) GetGeneratedValidationRule(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.GetGeneratedValidationRuleResponse, error) {
	out := new(common.GetGeneratedValidationRuleResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/GetGeneratedValidationRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) ListGeneratedValidationRuleVersions(ctx context.Context, in *common.GetDefinition, opts ...grpc.CallOption) (*common.ListVersionResponse, error) {
	out := new(common.ListVersionResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/ListGeneratedValidationRuleVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) GetGeneratedValidationRuleVersion(ctx context.Context, in *common.VersionRequest, opts ...grpc.CallOption) (*common.GetGeneratedValidationRuleResponse, error) {
	out := new(common.GetGeneratedValidationRuleResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/GetGeneratedValidationRuleVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validatorServiceClient) RdlCheck(ctx context.Context, in *common.RdlCheckRequest, opts ...grpc.CallOption) (*common.MessageResponse, error) {
	out := new(common.MessageResponse)
	err := c.cc.Invoke(ctx, "/titanium.ValidatorService/RdlCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ValidatorServiceServer is the server API for ValidatorService service.
// All implementations must embed UnimplementedValidatorServiceServer
// for forward compatibility
type ValidatorServiceServer interface {
	// AddValidationRule is a method used to add a validation rule to the system.
	// Backoffice users can create a new validation ruleset in the 'global' scope, for each asset class.
	// Participant users can create a new validation ruleset in its own scope, for each asset class.
	// Backoffice users can represent any participant and create a new validation ruleset in that participant's scope.
	// The default scope is used if no scope is given in the request ('global' for the operator, participant scope for that participant user).
	// The authorization will be fetched from the user's token. It will do an update if a validation rule with the same name already exists.
	//
	// Request for backoffice user:
	// {
	//
	//	"definition": {
	//	  "descriptor_name":"foreign_exchange-vanilla-options",
	//	  "criteria":[
	//	    {
	//	      "name":"FX-V-FXO: Option Instrument Parameter: Forward Points",
	//	      "description":"This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \"Forward Points\".",
	//	      "tags":[
	//	        "forward points"
	//	      ],
	//	      "metadata":[
	//
	//	      ],
	//	      "rule":"[\"foreign_exchange-vanilla-options.option_instrument_parameter\",\"$eq_case_insensitive\",\"Forward Points\"]",
	//	      "validations":[
	//	        {
	//	          "name":"FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check",
	//	          "severity":1,
	//	          "rule_type":"input_data",
	//	          "tags":[
	//
	//	          ],
	//	          "description":"Compare the fwrd_conversion_factor for a given underlying against the expected values.",
	//	          "rule":"[ { \"$lut_name\": \"conversion_factor\", \"$get\": [ \"foreign_exchange-vanilla-options.underlying\" ] }, \"$eq\", \"foreign_exchange-vanilla-options.fwrd_conversion_factor\" ]",
	//	          "error":{
	//	            "message":"[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].",
	//	            "message_args":[
	//	              "foreign_exchange-vanilla-options.fwrd_conversion_factor",
	//	              "foreign_exchange-vanilla-options.underlying"
	//	            ]
	//	          }
	//	        }
	//	      ]
	//	    }
	//	  ]
	//	},
	//
	// "scope": "global",
	// "descriptor_name": "foreign_exchange-vanilla-options"
	// }
	//
	// Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "ac49453d-cc9c-11ec-8bac-5314d58ea570",
	//	       "descriptor_name": "fx_forward"
	//	   }
	//	}
	//
	// Error response:
	//
	// Push to non ‘global’ scope :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Invalid argument: only support 'global' scope"
	//	   }
	//	}
	//
	// Unauthorized user :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Invalid auth token - only operator is allowed to add validation rules"
	//	   }
	//	}
	//
	// Missing argument :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Missing argument: descriptor_name"
	//	   }
	//	}
	//
	// Invalid rule definition - rule col mismatch with descriptor :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Rule [fx_fwd] compile failed, details: Column [submission_clienttt] not found in schema [fx_forward]"
	//	   }
	//	}
	//
	// Invalid rule definition - RDL syntax error :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Rule [fx_fwd] compile failed, details: line 1:14 no viable alternative at input '[{\"$lower\":\"fx_forward.submission_service\"'"
	//	   }
	//	}
	//
	// Dependencies not found - dependencies could be: descriptor, named lut, custom function :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Rule [fx_fwd] compile failed, details: Invalid rule expression [ { \"$lut_name\" : \"tenor\", \"$exist\" : [\"fx_forward.submission_tenor\"] } ]\n\terr: com.peernova.api.searchmetadata.metadata.exceptions.MetadataNotFoundException: No Look Up Table by name [tenor] found in scope [global]"
	//	   }
	//	}
	//
	// Ruleset with same name already exist :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Validation rule for descriptor [fx_fwd] already exist"
	//	   }
	//	}
	AddValidationRule(context.Context, *common.ValidationRuleDefinition) (*common.AcknowledgeResponse, error)
	// GetValidationRule method retrieves information about a validation rule.
	// Both back office users and participant users can view validation rulesets.
	// The default scope is used if no scope is given in the request. Authorization is fetched from the user's token.
	// The rule can be retrieved by either descriptor name or UID.
	// If multiple versions of the rule exist, this method returns the latest version.
	//
	// Example of Request:
	//
	//	{
	//	 "descriptor_name": "fx_fwd"
	//	}
	//
	// Or:
	//
	//	{
	//	 "uid": "ac49453d-cc9c-11ec-8bac-5314d58ea570"
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "",
	//	       "definition": {
	//	           "descriptorName": "foreign_exchange-vanilla-options",
	//	           "criteria": [
	//	               {
	//	                   "name": "FX-V-FXO: Option Instrument Parameter: Forward Points",
	//	                   "description": "This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \"Forward Points\".",
	//	                   "rule": "[\"foreign_exchange-vanilla-options.option_instrument_parameter\",\"$eq_case_insensitive\",\"Forward Points\"]",
	//	                   "tags": [
	//	                       "forward points"
	//	                   ],
	//	                   "metadata": [],
	//	                   "validations": [
	//	                       {
	//	                           "name": "FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check",
	//	                           "description": "Compare the fwrd_conversion_factor for a given underlying against the expected values.",
	//	                           "rule": "[ { \"$lut_name\": \"conversion_factor\", \"$get\": [ \"foreign_exchange-vanilla-options.underlying\" ] }, \"$eq\", \"foreign_exchange-vanilla-options.fwrd_conversion_factor\" ]",
	//	                           "ruleType": "INPUT_DATA",
	//	                           "severity": 1,
	//	                           "tags": [],
	//	                           "error": {
	//	                               "message": "[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].",
	//	                               "messageArgs": [
	//	                                   "foreign_exchange-vanilla-options.fwrd_conversion_factor",
	//	                                   "foreign_exchange-vanilla-options.underlying"
	//	                               ]
	//	                           },
	//	                           "filter": ""
	//	                       }
	//	                   ]
	//	               }
	//	           ]
	//	       },
	//	       "scope": "global",
	//	       "descriptorName": "foreign_exchange-vanilla-options"
	//	   }
	//	}
	//
	// Example of Error response:
	//
	// Missing argument:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Missing argument: need either descriptor name or uid to get validation rule"
	//	   }
	//	}
	//
	// Resource not found :
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Rule [fx_fwd] not found, details: [fx_fwd] of service [VALIDATIONRULESET] does not exist in namespace [global]"
	//	   }
	//	}
	GetValidationRule(context.Context, *common.GetDefinition) (*common.GetValidationRuleResponse, error)
	// DisableValidationRule method disables a validation rule in the system.
	// The request includes the descriptor name and scope of the rule.
	// Example of Request:
	// {
	// "descriptor_name" : "foreign_exchange-vanilla-forwards",
	// "scope": "global"
	// }
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "",
	//	       "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	   }
	//	}
	DisableValidationRule(context.Context, *common.GetDefinition) (*common.AcknowledgeResponse, error)
	// EnableValidationRule method enables a validation rule that has been previously disabled.
	// The request includes the descriptor name and scope of the rule.
	// Example of Request:
	// {
	// "descriptor_name" : "foreign_exchange-vanilla-forwards",
	// "scope": "global"
	// }
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "",
	//	       "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	   }
	//	}
	EnableValidationRule(context.Context, *common.GetDefinition) (*common.AcknowledgeResponse, error)
	// ListValidationRules method is used to retrieve a list of validation rule names.
	// Both back office users and participant users can retrieve validation rulesets, but the scope and authorization will depend on the user.
	// The default scope is used if no scope is specified in the request.
	// The request may include an optional filter and orderBy parameter to refine the search results.
	// Pagination is also supported. The response will include a list of rule names matching the filter criteria.
	//
	// Example of Request:
	//
	//	{
	//	 "scope": "global",
	//	 "filter": ".*exchange.*",
	//	 "orderBy": {
	//	 	"order": "DESC"
	//	 }
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "results": [
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-vanilla-options"
	//	           },
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	           },
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-exotics-tarfs"
	//	           }
	//	       ]
	//	   }
	//	}
	//
	// Example of Request with pagination:
	//
	//	{
	//	 "scope": "global",
	//	 "filter": ".*exchange.*",
	//	 "orderBy": {
	//	 	"order": "DESC"
	//	 },
	//	 "limit": {
	//	 	"value": 2
	//	 },
	//	 "offset": 1
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "results": [
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	           },
	//	           {
	//	               "uid": "",
	//	               "descriptor_name": "foreign_exchange-exotics-tarfs"
	//	           }
	//	       ]
	//	   }
	//	}
	//
	// Example of Error response:
	// not ‘global’ scope:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Invalid argument: only support 'global' scope"
	//	   }
	//	}
	//
	// Invalid filter/regex:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Failed to list rules: Dangling meta character '*' near index 0\n*May*\n^"
	//	   }
	//	}
	ListValidationRules(context.Context, *common.ListRequest) (*common.ListRuleResponse, error)
	// ListValidationRuleVersions method is used to retrieve a list of versions for a given validation rule.
	// Both back office users and participant users can retrieve versions of validation rulesets, but the scope will depend on the user.
	// The request must specify the descriptor name for the validation rule.
	// The response will include a list of versions and their created timestamp.
	// If the requested rule is not found, an error response will be returned.
	//
	// Example of Request:
	//
	//	{
	//	 "descriptor_name": "fx_fwd"
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "versions": [
	//	           {
	//	               "versionId": "teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=",
	//	               "createdAt": "2022-05-04 16:20:58.0"
	//	           },
	//	           {
	//	               "versionId": "mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=",
	//	               "createdAt": "2022-05-04 16:17:19.0"
	//	           },
	//	           {
	//	               "versionId": "6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=",
	//	               "createdAt": "2022-05-04 15:02:00.0"
	//	           }
	//	       ]
	//	   }
	//	}
	//
	// Example of Error response:
	// Resource not found:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Failed to get rule [fx_fwd] versions, details: Rule [fx_fwd_validation] not found"
	//	   }
	//	}
	ListValidationRuleVersions(context.Context, *common.GetDefinition) (*common.ListVersionResponse, error)
	// This is a method that allows both back office users and regular users to retrieve a specific version of a ruleset given the descriptor name and version ID.
	// The ruleset is used for validation purposes and contains criteria and rules for validating data submissions.
	// Back office users can retrieve a particular version of a ruleset from any scope, while participant users can only retrieve a version of a ruleset from either the global scope or their own scope.
	//
	// Example of Request:
	// GET /api/v1/validation/rule/version/fx_fwd_May04/teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "uid": "",
	//	       "definition": {
	//	           "descriptorName": "foreign_exchange-vanilla-options",
	//	           "criteria": [
	//	               {
	//	                   "name": "FX-V-FXO: Option Instrument Parameter: Forward Points",
	//	                   "description": "This criteria element contains validation rules that will be applied to all fx-vanilla-options data submission rows where option_instrument_parameter equals \"Forward Points\".",
	//	                   "rule": "[\"foreign_exchange-vanilla-options.option_instrument_parameter\",\"$eq_case_insensitive\",\"Forward Points\"]",
	//	                   "tags": [
	//	                       "forward points"
	//	                   ],
	//	                   "metadata": [],
	//	                   "validations": [
	//	                       {
	//	                           "name": "FX-V-FXO: Forward Points: Forward Conversion Factor: Exiting Value Check",
	//	                           "description": "Compare the fwrd_conversion_factor for a given underlying against the expected values.",
	//	                           "rule": "[ { \"$lut_name\": \"conversion_factor\", \"$get\": [ \"foreign_exchange-vanilla-options.underlying\" ] }, \"$eq\", \"foreign_exchange-vanilla-options.fwrd_conversion_factor\" ]",
	//	                           "ruleType": "INPUT_DATA",
	//	                           "severity": 1,
	//	                           "tags": [],
	//	                           "error": {
	//	                               "message": "[%s] is not a conversion factor used in consensus. Please update the conversion factor for this underlying -- [%s].",
	//	                               "messageArgs": [
	//	                                   "foreign_exchange-vanilla-options.fwrd_conversion_factor",
	//	                                   "foreign_exchange-vanilla-options.underlying"
	//	                               ]
	//	                           },
	//	                           "filter": ""
	//	                       }
	//	                   ]
	//	               }
	//	           ]
	//	       },
	//	       "scope": "global",
	//	       "descriptorName": "foreign_exchange-vanilla-options"
	//	   }
	//	}
	//
	// Example of Error response:
	// Resource not found:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Failed to get rule [fx_fwd_May04], details: MetaData entity not found: name [fx_fwd_May04] version: [teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk] in namespace: [global]"
	//	   }
	//	}
	GetValidationRuleVersion(context.Context, *common.VersionRequest) (*common.GetValidationRuleResponse, error)
	// GetGeneratedValidationRule method allows back office users to view all generated validation rulesets, including Java rulesets.
	// Participant users can only view global generated validation rulesets and rulesets within their own scope.
	// If no scope is given in the request, the default scope is used ("global" for operators and participant scope for the participant user).
	// Authorization is fetched from the user's token.
	// This method returns the latest version of the generated ruleset if multiple versions exist.
	//
	// Example of Request:
	//
	//	{
	//	 "descriptor_name": "foreign_exchange-vanilla-forwards"
	//	}
	GetGeneratedValidationRule(context.Context, *common.GetDefinition) (*common.GetGeneratedValidationRuleResponse, error)
	// ListGeneratedValidationRuleVersions method returns a list of generated ruleset version IDs along with their creation timestamps.
	// The request requires a descriptor name. If the requested ruleset is not found, an error response is returned.
	//
	// Example of Request:
	//
	//	{
	//	 "descriptor_name": "fx_fwd"
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "versions": [
	//	           {
	//	               "versionId": "teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=",
	//	               "createdAt": "2022-05-04 16:20:58.0"
	//	           },
	//	           {
	//	               "versionId": "mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=",
	//	               "createdAt": "2022-05-04 16:17:19.0"
	//	           },
	//	           {
	//	               "versionId": "6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=",
	//	               "createdAt": "2022-05-04 15:02:00.0"
	//	           }
	//	       ]
	//	   }
	//	}
	//
	// Example of Error response:
	// Resource not found:
	//
	//	{
	//	   "error": {
	//	       "code": 70,
	//	       "message": "Failed to get rule [fx_fwd] versions, details: Rule [fx_fwd] not found"
	//	   }
	//	}
	ListGeneratedValidationRuleVersions(context.Context, *common.GetDefinition) (*common.ListVersionResponse, error)
	// GetGeneratedValidationRuleVersion method allows the user to view a particular version of a generated ruleset.
	// The request requires a descriptor name and a version ID.
	// If the requested ruleset version is not found, an error response is returned.
	//
	// Example of Request:
	// GET /api/v1/validation/rule/generated/version/foreign_exchange-vanilla-forwards
	// /QHF5uuOTjGprb3FRsI7ybBnU6-Ub32Xq8Q399PtQWeQ=
	//
	//	{
	//	 "scope": "global"
	//	}
	//
	// Example of Response:
	//
	//	{
	//	    "data": {
	//	         "versions": [
	//	             {
	//	                "versionId": "teTYb9Fs_lIOoPQJukM6dY3aJdiMqT-SdBPdvYfJAjk=",
	//	                "createdAt": "2022-05-04 16:20:58.0"
	//	             },
	//	             {
	//	                 "versionId": "mwpGZcWNc2zFgweB5rcNmAbcxqekM_zUCdpVrl_V6BM=",
	//	                 "createdAt": "2022-05-04 16:17:19.0"
	//	             },
	//	             {
	//	                 "versionId": "6pfCXN2rFnIAMoDHy7VIFh6HmoyDu3njXkpwzeTp2nc=",
	//	                 "createdAt": "2022-05-04 15:02:00.0"
	//	             }
	//	         ]
	//	     }
	//	 }
	GetGeneratedValidationRuleVersion(context.Context, *common.VersionRequest) (*common.GetGeneratedValidationRuleResponse, error)
	// RdlCheck method checks the syntax of a given RDL (Rule Description Language) expression.
	// It takes a RdlCheckRequest message as input and returns a MessageResponse message.
	//
	// Example of Request:
	//
	//	{
	//	 "rdl": "[\"a\", \"$eq\", \"b\""
	//	}
	//
	// Example of Response:
	//
	//	{
	//	   "data": {
	//	       "message": "success"
	//	   }
	//	}
	//
	// Example of Error response:
	// Resource not found:
	//
	//	{
	//	   "error": {
	//	       "code": 69,
	//	       "message": "rdl [[\"a\", \"$eq\", \"b\"] cannot be parsed. Error: line 1:16 missing ']' at '<EOF>'"
	//	   }
	//	}
	RdlCheck(context.Context, *common.RdlCheckRequest) (*common.MessageResponse, error)
	mustEmbedUnimplementedValidatorServiceServer()
}

// UnimplementedValidatorServiceServer must be embedded to have forward compatible implementations.
type UnimplementedValidatorServiceServer struct {
}

func (UnimplementedValidatorServiceServer) AddValidationRule(context.Context, *common.ValidationRuleDefinition) (*common.AcknowledgeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddValidationRule not implemented")
}
func (UnimplementedValidatorServiceServer) GetValidationRule(context.Context, *common.GetDefinition) (*common.GetValidationRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidationRule not implemented")
}
func (UnimplementedValidatorServiceServer) DisableValidationRule(context.Context, *common.GetDefinition) (*common.AcknowledgeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableValidationRule not implemented")
}
func (UnimplementedValidatorServiceServer) EnableValidationRule(context.Context, *common.GetDefinition) (*common.AcknowledgeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableValidationRule not implemented")
}
func (UnimplementedValidatorServiceServer) ListValidationRules(context.Context, *common.ListRequest) (*common.ListRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidationRules not implemented")
}
func (UnimplementedValidatorServiceServer) ListValidationRuleVersions(context.Context, *common.GetDefinition) (*common.ListVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidationRuleVersions not implemented")
}
func (UnimplementedValidatorServiceServer) GetValidationRuleVersion(context.Context, *common.VersionRequest) (*common.GetValidationRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidationRuleVersion not implemented")
}
func (UnimplementedValidatorServiceServer) GetGeneratedValidationRule(context.Context, *common.GetDefinition) (*common.GetGeneratedValidationRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGeneratedValidationRule not implemented")
}
func (UnimplementedValidatorServiceServer) ListGeneratedValidationRuleVersions(context.Context, *common.GetDefinition) (*common.ListVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGeneratedValidationRuleVersions not implemented")
}
func (UnimplementedValidatorServiceServer) GetGeneratedValidationRuleVersion(context.Context, *common.VersionRequest) (*common.GetGeneratedValidationRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGeneratedValidationRuleVersion not implemented")
}
func (UnimplementedValidatorServiceServer) RdlCheck(context.Context, *common.RdlCheckRequest) (*common.MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RdlCheck not implemented")
}
func (UnimplementedValidatorServiceServer) mustEmbedUnimplementedValidatorServiceServer() {}

// UnsafeValidatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ValidatorServiceServer will
// result in compilation errors.
type UnsafeValidatorServiceServer interface {
	mustEmbedUnimplementedValidatorServiceServer()
}

func RegisterValidatorServiceServer(s grpc.ServiceRegistrar, srv ValidatorServiceServer) {
	s.RegisterService(&ValidatorService_ServiceDesc, srv)
}

func _ValidatorService_AddValidationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ValidationRuleDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).AddValidationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/AddValidationRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).AddValidationRule(ctx, req.(*common.ValidationRuleDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_GetValidationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.GetDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).GetValidationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/GetValidationRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).GetValidationRule(ctx, req.(*common.GetDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_DisableValidationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.GetDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).DisableValidationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/DisableValidationRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).DisableValidationRule(ctx, req.(*common.GetDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_EnableValidationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.GetDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).EnableValidationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/EnableValidationRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).EnableValidationRule(ctx, req.(*common.GetDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_ListValidationRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).ListValidationRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/ListValidationRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).ListValidationRules(ctx, req.(*common.ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_ListValidationRuleVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.GetDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).ListValidationRuleVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/ListValidationRuleVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).ListValidationRuleVersions(ctx, req.(*common.GetDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_GetValidationRuleVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).GetValidationRuleVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/GetValidationRuleVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).GetValidationRuleVersion(ctx, req.(*common.VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_GetGeneratedValidationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.GetDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).GetGeneratedValidationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/GetGeneratedValidationRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).GetGeneratedValidationRule(ctx, req.(*common.GetDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_ListGeneratedValidationRuleVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.GetDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).ListGeneratedValidationRuleVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/ListGeneratedValidationRuleVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).ListGeneratedValidationRuleVersions(ctx, req.(*common.GetDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_GetGeneratedValidationRuleVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).GetGeneratedValidationRuleVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/GetGeneratedValidationRuleVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).GetGeneratedValidationRuleVersion(ctx, req.(*common.VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidatorService_RdlCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RdlCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServiceServer).RdlCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ValidatorService/RdlCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServiceServer).RdlCheck(ctx, req.(*common.RdlCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ValidatorService_ServiceDesc is the grpc.ServiceDesc for ValidatorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ValidatorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "titanium.ValidatorService",
	HandlerType: (*ValidatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddValidationRule",
			Handler:    _ValidatorService_AddValidationRule_Handler,
		},
		{
			MethodName: "GetValidationRule",
			Handler:    _ValidatorService_GetValidationRule_Handler,
		},
		{
			MethodName: "DisableValidationRule",
			Handler:    _ValidatorService_DisableValidationRule_Handler,
		},
		{
			MethodName: "EnableValidationRule",
			Handler:    _ValidatorService_EnableValidationRule_Handler,
		},
		{
			MethodName: "ListValidationRules",
			Handler:    _ValidatorService_ListValidationRules_Handler,
		},
		{
			MethodName: "ListValidationRuleVersions",
			Handler:    _ValidatorService_ListValidationRuleVersions_Handler,
		},
		{
			MethodName: "GetValidationRuleVersion",
			Handler:    _ValidatorService_GetValidationRuleVersion_Handler,
		},
		{
			MethodName: "GetGeneratedValidationRule",
			Handler:    _ValidatorService_GetGeneratedValidationRule_Handler,
		},
		{
			MethodName: "ListGeneratedValidationRuleVersions",
			Handler:    _ValidatorService_ListGeneratedValidationRuleVersions_Handler,
		},
		{
			MethodName: "GetGeneratedValidationRuleVersion",
			Handler:    _ValidatorService_GetGeneratedValidationRuleVersion_Handler,
		},
		{
			MethodName: "RdlCheck",
			Handler:    _ValidatorService_RdlCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "public/validation_service.proto",
}
