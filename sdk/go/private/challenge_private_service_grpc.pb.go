// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package private

import (
	context "context"
	common "github.com/peernova/clearconsensus-sdk/sdk/go/common"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ChallengePrivateServiceClient is the client API for ChallengePrivateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChallengePrivateServiceClient interface {
	// ChallengeActive returns active challenges(according to request) in active status(challenge process is active).
	ChallengeActive(ctx context.Context, in *common.ChallengeActiveRequest, opts ...grpc.CallOption) (*common.ChallengeActiveResponse, error)
	// ChallengeList returns list of challenges according to request.
	ChallengeList(ctx context.Context, in *common.ChallengeListRequest, opts ...grpc.CallOption) (*common.ChallengeListResponse, error)
	// ChallengeHistory return already closed challenges according to request.
	ChallengeHistory(ctx context.Context, in *common.ChallengeHistoryRequest, opts ...grpc.CallOption) (*common.ChallengeHistoryResponse, error)
	// ChallengeDecision sets decision of the challenge according to request.
	ChallengeDecision(ctx context.Context, in *common.ChallengeDecisionRequest, opts ...grpc.CallOption) (*common.MessageResponse, error)
	// ChallengeFreezeAction makes challenge process stopped or not according to request.
	ChallengeFreezeAction(ctx context.Context, in *common.ChallengeFreezeActionRequest, opts ...grpc.CallOption) (*common.MessageResponse, error)
}

type challengePrivateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChallengePrivateServiceClient(cc grpc.ClientConnInterface) ChallengePrivateServiceClient {
	return &challengePrivateServiceClient{cc}
}

func (c *challengePrivateServiceClient) ChallengeActive(ctx context.Context, in *common.ChallengeActiveRequest, opts ...grpc.CallOption) (*common.ChallengeActiveResponse, error) {
	out := new(common.ChallengeActiveResponse)
	err := c.cc.Invoke(ctx, "/titanium.ChallengePrivateService/ChallengeActive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengePrivateServiceClient) ChallengeList(ctx context.Context, in *common.ChallengeListRequest, opts ...grpc.CallOption) (*common.ChallengeListResponse, error) {
	out := new(common.ChallengeListResponse)
	err := c.cc.Invoke(ctx, "/titanium.ChallengePrivateService/ChallengeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengePrivateServiceClient) ChallengeHistory(ctx context.Context, in *common.ChallengeHistoryRequest, opts ...grpc.CallOption) (*common.ChallengeHistoryResponse, error) {
	out := new(common.ChallengeHistoryResponse)
	err := c.cc.Invoke(ctx, "/titanium.ChallengePrivateService/ChallengeHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengePrivateServiceClient) ChallengeDecision(ctx context.Context, in *common.ChallengeDecisionRequest, opts ...grpc.CallOption) (*common.MessageResponse, error) {
	out := new(common.MessageResponse)
	err := c.cc.Invoke(ctx, "/titanium.ChallengePrivateService/ChallengeDecision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengePrivateServiceClient) ChallengeFreezeAction(ctx context.Context, in *common.ChallengeFreezeActionRequest, opts ...grpc.CallOption) (*common.MessageResponse, error) {
	out := new(common.MessageResponse)
	err := c.cc.Invoke(ctx, "/titanium.ChallengePrivateService/ChallengeFreezeAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChallengePrivateServiceServer is the server API for ChallengePrivateService service.
// All implementations must embed UnimplementedChallengePrivateServiceServer
// for forward compatibility
type ChallengePrivateServiceServer interface {
	// ChallengeActive returns active challenges(according to request) in active status(challenge process is active).
	ChallengeActive(context.Context, *common.ChallengeActiveRequest) (*common.ChallengeActiveResponse, error)
	// ChallengeList returns list of challenges according to request.
	ChallengeList(context.Context, *common.ChallengeListRequest) (*common.ChallengeListResponse, error)
	// ChallengeHistory return already closed challenges according to request.
	ChallengeHistory(context.Context, *common.ChallengeHistoryRequest) (*common.ChallengeHistoryResponse, error)
	// ChallengeDecision sets decision of the challenge according to request.
	ChallengeDecision(context.Context, *common.ChallengeDecisionRequest) (*common.MessageResponse, error)
	// ChallengeFreezeAction makes challenge process stopped or not according to request.
	ChallengeFreezeAction(context.Context, *common.ChallengeFreezeActionRequest) (*common.MessageResponse, error)
	mustEmbedUnimplementedChallengePrivateServiceServer()
}

// UnimplementedChallengePrivateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChallengePrivateServiceServer struct {
}

func (UnimplementedChallengePrivateServiceServer) ChallengeActive(context.Context, *common.ChallengeActiveRequest) (*common.ChallengeActiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeActive not implemented")
}
func (UnimplementedChallengePrivateServiceServer) ChallengeList(context.Context, *common.ChallengeListRequest) (*common.ChallengeListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeList not implemented")
}
func (UnimplementedChallengePrivateServiceServer) ChallengeHistory(context.Context, *common.ChallengeHistoryRequest) (*common.ChallengeHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeHistory not implemented")
}
func (UnimplementedChallengePrivateServiceServer) ChallengeDecision(context.Context, *common.ChallengeDecisionRequest) (*common.MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeDecision not implemented")
}
func (UnimplementedChallengePrivateServiceServer) ChallengeFreezeAction(context.Context, *common.ChallengeFreezeActionRequest) (*common.MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChallengeFreezeAction not implemented")
}
func (UnimplementedChallengePrivateServiceServer) mustEmbedUnimplementedChallengePrivateServiceServer() {
}

// UnsafeChallengePrivateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChallengePrivateServiceServer will
// result in compilation errors.
type UnsafeChallengePrivateServiceServer interface {
	mustEmbedUnimplementedChallengePrivateServiceServer()
}

func RegisterChallengePrivateServiceServer(s grpc.ServiceRegistrar, srv ChallengePrivateServiceServer) {
	s.RegisterService(&ChallengePrivateService_ServiceDesc, srv)
}

func _ChallengePrivateService_ChallengeActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ChallengeActiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengePrivateServiceServer).ChallengeActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ChallengePrivateService/ChallengeActive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengePrivateServiceServer).ChallengeActive(ctx, req.(*common.ChallengeActiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengePrivateService_ChallengeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ChallengeListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengePrivateServiceServer).ChallengeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ChallengePrivateService/ChallengeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengePrivateServiceServer).ChallengeList(ctx, req.(*common.ChallengeListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengePrivateService_ChallengeHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ChallengeHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengePrivateServiceServer).ChallengeHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ChallengePrivateService/ChallengeHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengePrivateServiceServer).ChallengeHistory(ctx, req.(*common.ChallengeHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengePrivateService_ChallengeDecision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ChallengeDecisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengePrivateServiceServer).ChallengeDecision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ChallengePrivateService/ChallengeDecision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengePrivateServiceServer).ChallengeDecision(ctx, req.(*common.ChallengeDecisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengePrivateService_ChallengeFreezeAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ChallengeFreezeActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengePrivateServiceServer).ChallengeFreezeAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/titanium.ChallengePrivateService/ChallengeFreezeAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengePrivateServiceServer).ChallengeFreezeAction(ctx, req.(*common.ChallengeFreezeActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChallengePrivateService_ServiceDesc is the grpc.ServiceDesc for ChallengePrivateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChallengePrivateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "titanium.ChallengePrivateService",
	HandlerType: (*ChallengePrivateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ChallengeActive",
			Handler:    _ChallengePrivateService_ChallengeActive_Handler,
		},
		{
			MethodName: "ChallengeList",
			Handler:    _ChallengePrivateService_ChallengeList_Handler,
		},
		{
			MethodName: "ChallengeHistory",
			Handler:    _ChallengePrivateService_ChallengeHistory_Handler,
		},
		{
			MethodName: "ChallengeDecision",
			Handler:    _ChallengePrivateService_ChallengeDecision_Handler,
		},
		{
			MethodName: "ChallengeFreezeAction",
			Handler:    _ChallengePrivateService_ChallengeFreezeAction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "private/challenge_private_service.proto",
}
