/* eslint-disable */
/*Generated by GenDocu.com*/
// package: titanium
// file: common/challenge.proto

import * as jspb from "google-protobuf";
import * as google_protobuf_struct_pb from "google-protobuf/google/protobuf/struct_pb";
import * as common_gateway_base_pb from "../common/gateway_base_pb";

export class ChallengeFormMetaRequest extends jspb.Message {
  getAssetId(): string;
  setAssetId(value: string): void;

  getEvidenceType(): EvidenceTypeMap[keyof EvidenceTypeMap];
  setEvidenceType(value: EvidenceTypeMap[keyof EvidenceTypeMap]): void;

  getSubmissionId(): string;
  setSubmissionId(value: string): void;

  getTraceName(): string;
  setTraceName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormMetaRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormMetaRequest): ChallengeFormMetaRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormMetaRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormMetaRequest;
  static deserializeBinaryFromReader(message: ChallengeFormMetaRequest, reader: jspb.BinaryReader): ChallengeFormMetaRequest;
}

export namespace ChallengeFormMetaRequest {
  export type AsObject = {
    assetId: string,
    evidenceType: EvidenceTypeMap[keyof EvidenceTypeMap],
    submissionId: string,
    traceName: string,
  }
}

export class ChallengeFormMetaResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): ChallengeFormMetaResponseData | undefined;
  setData(value?: ChallengeFormMetaResponseData): void;

  hasError(): boolean;
  clearError(): void;
  getError(): common_gateway_base_pb.Error | undefined;
  setError(value?: common_gateway_base_pb.Error): void;

  getResponseCase(): ChallengeFormMetaResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormMetaResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormMetaResponse): ChallengeFormMetaResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormMetaResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormMetaResponse;
  static deserializeBinaryFromReader(message: ChallengeFormMetaResponse, reader: jspb.BinaryReader): ChallengeFormMetaResponse;
}

export namespace ChallengeFormMetaResponse {
  export type AsObject = {
    data?: ChallengeFormMetaResponseData.AsObject,
    error?: common_gateway_base_pb.Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class ChallengeFormMetaResponseData extends jspb.Message {
  clearRowsList(): void;
  getRowsList(): Array<ChallengeFormGeneralRow>;
  setRowsList(value: Array<ChallengeFormGeneralRow>): void;
  addRows(value?: ChallengeFormGeneralRow, index?: number): ChallengeFormGeneralRow;

  clearOneOfFieldsList(): void;
  getOneOfFieldsList(): Array<ChallengeFormOneOfFields>;
  setOneOfFieldsList(value: Array<ChallengeFormOneOfFields>): void;
  addOneOfFields(value?: ChallengeFormOneOfFields, index?: number): ChallengeFormOneOfFields;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormMetaResponseData.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormMetaResponseData): ChallengeFormMetaResponseData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormMetaResponseData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormMetaResponseData;
  static deserializeBinaryFromReader(message: ChallengeFormMetaResponseData, reader: jspb.BinaryReader): ChallengeFormMetaResponseData;
}

export namespace ChallengeFormMetaResponseData {
  export type AsObject = {
    rowsList: Array<ChallengeFormGeneralRow.AsObject>,
    oneOfFieldsList: Array<ChallengeFormOneOfFields.AsObject>,
  }
}

export class ChallengeFormOneOfFields extends jspb.Message {
  clearNamesList(): void;
  getNamesList(): Array<string>;
  setNamesList(value: Array<string>): void;
  addNames(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormOneOfFields.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormOneOfFields): ChallengeFormOneOfFields.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormOneOfFields, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormOneOfFields;
  static deserializeBinaryFromReader(message: ChallengeFormOneOfFields, reader: jspb.BinaryReader): ChallengeFormOneOfFields;
}

export namespace ChallengeFormOneOfFields {
  export type AsObject = {
    namesList: Array<string>,
  }
}

export class ChallengeFormGeneralRow extends jspb.Message {
  getField(): string;
  setField(value: string): void;

  getTooltip(): string;
  setTooltip(value: string): void;

  getType(): string;
  setType(value: string): void;

  hasPrecision(): boolean;
  clearPrecision(): void;
  getPrecision(): ChallengeFormGeneralRowPrecision | undefined;
  setPrecision(value?: ChallengeFormGeneralRowPrecision): void;

  hasMax(): boolean;
  clearMax(): void;
  getMax(): ChallengeFormGeneralRowMax | undefined;
  setMax(value?: ChallengeFormGeneralRowMax): void;

  hasMin(): boolean;
  clearMin(): void;
  getMin(): ChallengeFormGeneralRowMin | undefined;
  setMin(value?: ChallengeFormGeneralRowMin): void;

  getRegex(): string;
  setRegex(value: string): void;

  hasMaxLength(): boolean;
  clearMaxLength(): void;
  getMaxLength(): ChallengeFormGeneralRowMaxLength | undefined;
  setMaxLength(value?: ChallengeFormGeneralRowMaxLength): void;

  hasMinLength(): boolean;
  clearMinLength(): void;
  getMinLength(): ChallengeFormGeneralRowMinLength | undefined;
  setMinLength(value?: ChallengeFormGeneralRowMinLength): void;

  hasValue(): boolean;
  clearValue(): void;
  getValue(): google_protobuf_struct_pb.Value | undefined;
  setValue(value?: google_protobuf_struct_pb.Value): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormGeneralRow.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormGeneralRow): ChallengeFormGeneralRow.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormGeneralRow, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormGeneralRow;
  static deserializeBinaryFromReader(message: ChallengeFormGeneralRow, reader: jspb.BinaryReader): ChallengeFormGeneralRow;
}

export namespace ChallengeFormGeneralRow {
  export type AsObject = {
    field: string,
    tooltip: string,
    type: string,
    precision?: ChallengeFormGeneralRowPrecision.AsObject,
    max?: ChallengeFormGeneralRowMax.AsObject,
    min?: ChallengeFormGeneralRowMin.AsObject,
    regex: string,
    maxLength?: ChallengeFormGeneralRowMaxLength.AsObject,
    minLength?: ChallengeFormGeneralRowMinLength.AsObject,
    value?: google_protobuf_struct_pb.Value.AsObject,
  }
}

export class ChallengeFormGeneralRowPrecision extends jspb.Message {
  getValue(): number;
  setValue(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormGeneralRowPrecision.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormGeneralRowPrecision): ChallengeFormGeneralRowPrecision.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormGeneralRowPrecision, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormGeneralRowPrecision;
  static deserializeBinaryFromReader(message: ChallengeFormGeneralRowPrecision, reader: jspb.BinaryReader): ChallengeFormGeneralRowPrecision;
}

export namespace ChallengeFormGeneralRowPrecision {
  export type AsObject = {
    value: number,
  }
}

export class ChallengeFormGeneralRowMax extends jspb.Message {
  getValue(): number;
  setValue(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormGeneralRowMax.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormGeneralRowMax): ChallengeFormGeneralRowMax.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormGeneralRowMax, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormGeneralRowMax;
  static deserializeBinaryFromReader(message: ChallengeFormGeneralRowMax, reader: jspb.BinaryReader): ChallengeFormGeneralRowMax;
}

export namespace ChallengeFormGeneralRowMax {
  export type AsObject = {
    value: number,
  }
}

export class ChallengeFormGeneralRowMin extends jspb.Message {
  getValue(): number;
  setValue(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormGeneralRowMin.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormGeneralRowMin): ChallengeFormGeneralRowMin.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormGeneralRowMin, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormGeneralRowMin;
  static deserializeBinaryFromReader(message: ChallengeFormGeneralRowMin, reader: jspb.BinaryReader): ChallengeFormGeneralRowMin;
}

export namespace ChallengeFormGeneralRowMin {
  export type AsObject = {
    value: number,
  }
}

export class ChallengeFormGeneralRowMaxLength extends jspb.Message {
  getValue(): number;
  setValue(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormGeneralRowMaxLength.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormGeneralRowMaxLength): ChallengeFormGeneralRowMaxLength.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormGeneralRowMaxLength, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormGeneralRowMaxLength;
  static deserializeBinaryFromReader(message: ChallengeFormGeneralRowMaxLength, reader: jspb.BinaryReader): ChallengeFormGeneralRowMaxLength;
}

export namespace ChallengeFormGeneralRowMaxLength {
  export type AsObject = {
    value: number,
  }
}

export class ChallengeFormGeneralRowMinLength extends jspb.Message {
  getValue(): number;
  setValue(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFormGeneralRowMinLength.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFormGeneralRowMinLength): ChallengeFormGeneralRowMinLength.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFormGeneralRowMinLength, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFormGeneralRowMinLength;
  static deserializeBinaryFromReader(message: ChallengeFormGeneralRowMinLength, reader: jspb.BinaryReader): ChallengeFormGeneralRowMinLength;
}

export namespace ChallengeFormGeneralRowMinLength {
  export type AsObject = {
    value: number,
  }
}

export class ChallengeCreateRequest extends jspb.Message {
  getAssetId(): string;
  setAssetId(value: string): void;

  getEvidenceType(): EvidenceTypeMap[keyof EvidenceTypeMap];
  setEvidenceType(value: EvidenceTypeMap[keyof EvidenceTypeMap]): void;

  getSubmittedDate(): string;
  setSubmittedDate(value: string): void;

  getSubmittedId(): string;
  setSubmittedId(value: string): void;

  getSubmittedUrl(): string;
  setSubmittedUrl(value: string): void;

  getDate(): string;
  setDate(value: string): void;

  getTime(): string;
  setTime(value: string): void;

  clearGeneralFieldsList(): void;
  getGeneralFieldsList(): Array<string>;
  setGeneralFieldsList(value: Array<string>): void;
  addGeneralFields(value: string, index?: number): string;

  getNote(): string;
  setNote(value: string): void;

  clearAttachmentsList(): void;
  getAttachmentsList(): Array<Attachment>;
  setAttachmentsList(value: Array<Attachment>): void;
  addAttachments(value?: Attachment, index?: number): Attachment;

  getTraceName(): string;
  setTraceName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeCreateRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeCreateRequest): ChallengeCreateRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeCreateRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeCreateRequest;
  static deserializeBinaryFromReader(message: ChallengeCreateRequest, reader: jspb.BinaryReader): ChallengeCreateRequest;
}

export namespace ChallengeCreateRequest {
  export type AsObject = {
    assetId: string,
    evidenceType: EvidenceTypeMap[keyof EvidenceTypeMap],
    submittedDate: string,
    submittedId: string,
    submittedUrl: string,
    date: string,
    time: string,
    generalFieldsList: Array<string>,
    note: string,
    attachmentsList: Array<Attachment.AsObject>,
    traceName: string,
  }
}

export class ChallengeCreateResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): ChallengeCreateResponseData | undefined;
  setData(value?: ChallengeCreateResponseData): void;

  hasError(): boolean;
  clearError(): void;
  getError(): common_gateway_base_pb.Error | undefined;
  setError(value?: common_gateway_base_pb.Error): void;

  getResponseCase(): ChallengeCreateResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeCreateResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeCreateResponse): ChallengeCreateResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeCreateResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeCreateResponse;
  static deserializeBinaryFromReader(message: ChallengeCreateResponse, reader: jspb.BinaryReader): ChallengeCreateResponse;
}

export namespace ChallengeCreateResponse {
  export type AsObject = {
    data?: ChallengeCreateResponseData.AsObject,
    error?: common_gateway_base_pb.Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class ChallengeCreateResponseData extends jspb.Message {
  getTicketId(): string;
  setTicketId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeCreateResponseData.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeCreateResponseData): ChallengeCreateResponseData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeCreateResponseData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeCreateResponseData;
  static deserializeBinaryFromReader(message: ChallengeCreateResponseData, reader: jspb.BinaryReader): ChallengeCreateResponseData;
}

export namespace ChallengeCreateResponseData {
  export type AsObject = {
    ticketId: string,
  }
}

export class ChallengeFreezeStatusRequest extends jspb.Message {
  getConsensusRunId(): string;
  setConsensusRunId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFreezeStatusRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFreezeStatusRequest): ChallengeFreezeStatusRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFreezeStatusRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFreezeStatusRequest;
  static deserializeBinaryFromReader(message: ChallengeFreezeStatusRequest, reader: jspb.BinaryReader): ChallengeFreezeStatusRequest;
}

export namespace ChallengeFreezeStatusRequest {
  export type AsObject = {
    consensusRunId: string,
  }
}

export class ChallengeFreezeActionRequest extends jspb.Message {
  getConsensusRunId(): string;
  setConsensusRunId(value: string): void;

  getAction(): ChallengeFreezeActionMap[keyof ChallengeFreezeActionMap];
  setAction(value: ChallengeFreezeActionMap[keyof ChallengeFreezeActionMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeFreezeActionRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeFreezeActionRequest): ChallengeFreezeActionRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeFreezeActionRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeFreezeActionRequest;
  static deserializeBinaryFromReader(message: ChallengeFreezeActionRequest, reader: jspb.BinaryReader): ChallengeFreezeActionRequest;
}

export namespace ChallengeFreezeActionRequest {
  export type AsObject = {
    consensusRunId: string,
    action: ChallengeFreezeActionMap[keyof ChallengeFreezeActionMap],
  }
}

export class ChallengeActiveRequest extends jspb.Message {
  getAssetId(): string;
  setAssetId(value: string): void;

  getFilter(): string;
  setFilter(value: string): void;

  hasOrderby(): boolean;
  clearOrderby(): void;
  getOrderby(): common_gateway_base_pb.OrderBy | undefined;
  setOrderby(value?: common_gateway_base_pb.OrderBy): void;

  hasLimit(): boolean;
  clearLimit(): void;
  getLimit(): common_gateway_base_pb.Limit | undefined;
  setLimit(value?: common_gateway_base_pb.Limit): void;

  getOffset(): number;
  setOffset(value: number): void;

  getTraceName(): string;
  setTraceName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeActiveRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeActiveRequest): ChallengeActiveRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeActiveRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeActiveRequest;
  static deserializeBinaryFromReader(message: ChallengeActiveRequest, reader: jspb.BinaryReader): ChallengeActiveRequest;
}

export namespace ChallengeActiveRequest {
  export type AsObject = {
    assetId: string,
    filter: string,
    orderby?: common_gateway_base_pb.OrderBy.AsObject,
    limit?: common_gateway_base_pb.Limit.AsObject,
    offset: number,
    traceName: string,
  }
}

export class ChallengeActiveResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): ChallengeActiveResponseData | undefined;
  setData(value?: ChallengeActiveResponseData): void;

  hasError(): boolean;
  clearError(): void;
  getError(): common_gateway_base_pb.Error | undefined;
  setError(value?: common_gateway_base_pb.Error): void;

  getResponseCase(): ChallengeActiveResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeActiveResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeActiveResponse): ChallengeActiveResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeActiveResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeActiveResponse;
  static deserializeBinaryFromReader(message: ChallengeActiveResponse, reader: jspb.BinaryReader): ChallengeActiveResponse;
}

export namespace ChallengeActiveResponse {
  export type AsObject = {
    data?: ChallengeActiveResponseData.AsObject,
    error?: common_gateway_base_pb.Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class ChallengeActiveResponseData extends jspb.Message {
  clearColumnsList(): void;
  getColumnsList(): Array<common_gateway_base_pb.ColumnInfo>;
  setColumnsList(value: Array<common_gateway_base_pb.ColumnInfo>): void;
  addColumns(value?: common_gateway_base_pb.ColumnInfo, index?: number): common_gateway_base_pb.ColumnInfo;

  clearRowsList(): void;
  getRowsList(): Array<ChallengeConsensusMetadata>;
  setRowsList(value: Array<ChallengeConsensusMetadata>): void;
  addRows(value?: ChallengeConsensusMetadata, index?: number): ChallengeConsensusMetadata;

  getTotalRows(): number;
  setTotalRows(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeActiveResponseData.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeActiveResponseData): ChallengeActiveResponseData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeActiveResponseData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeActiveResponseData;
  static deserializeBinaryFromReader(message: ChallengeActiveResponseData, reader: jspb.BinaryReader): ChallengeActiveResponseData;
}

export namespace ChallengeActiveResponseData {
  export type AsObject = {
    columnsList: Array<common_gateway_base_pb.ColumnInfo.AsObject>,
    rowsList: Array<ChallengeConsensusMetadata.AsObject>,
    totalRows: number,
  }
}

export class ChallengeConsensusMetadata extends jspb.Message {
  clearChallengesList(): void;
  getChallengesList(): Array<common_gateway_base_pb.ValuesRow>;
  setChallengesList(value: Array<common_gateway_base_pb.ValuesRow>): void;
  addChallenges(value?: common_gateway_base_pb.ValuesRow, index?: number): common_gateway_base_pb.ValuesRow;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeConsensusMetadata.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeConsensusMetadata): ChallengeConsensusMetadata.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeConsensusMetadata, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeConsensusMetadata;
  static deserializeBinaryFromReader(message: ChallengeConsensusMetadata, reader: jspb.BinaryReader): ChallengeConsensusMetadata;
}

export namespace ChallengeConsensusMetadata {
  export type AsObject = {
    challengesList: Array<common_gateway_base_pb.ValuesRow.AsObject>,
  }
}

export class ChallengeHistoryResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): ChallengeHistoryResponseData | undefined;
  setData(value?: ChallengeHistoryResponseData): void;

  hasError(): boolean;
  clearError(): void;
  getError(): common_gateway_base_pb.Error | undefined;
  setError(value?: common_gateway_base_pb.Error): void;

  getResponseCase(): ChallengeHistoryResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeHistoryResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeHistoryResponse): ChallengeHistoryResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeHistoryResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeHistoryResponse;
  static deserializeBinaryFromReader(message: ChallengeHistoryResponse, reader: jspb.BinaryReader): ChallengeHistoryResponse;
}

export namespace ChallengeHistoryResponse {
  export type AsObject = {
    data?: ChallengeHistoryResponseData.AsObject,
    error?: common_gateway_base_pb.Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class ChallengeHistoryResponseData extends jspb.Message {
  clearColumnsList(): void;
  getColumnsList(): Array<common_gateway_base_pb.ColumnInfo>;
  setColumnsList(value: Array<common_gateway_base_pb.ColumnInfo>): void;
  addColumns(value?: common_gateway_base_pb.ColumnInfo, index?: number): common_gateway_base_pb.ColumnInfo;

  clearRowsList(): void;
  getRowsList(): Array<common_gateway_base_pb.ValuesRow>;
  setRowsList(value: Array<common_gateway_base_pb.ValuesRow>): void;
  addRows(value?: common_gateway_base_pb.ValuesRow, index?: number): common_gateway_base_pb.ValuesRow;

  getTotalRows(): number;
  setTotalRows(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeHistoryResponseData.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeHistoryResponseData): ChallengeHistoryResponseData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeHistoryResponseData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeHistoryResponseData;
  static deserializeBinaryFromReader(message: ChallengeHistoryResponseData, reader: jspb.BinaryReader): ChallengeHistoryResponseData;
}

export namespace ChallengeHistoryResponseData {
  export type AsObject = {
    columnsList: Array<common_gateway_base_pb.ColumnInfo.AsObject>,
    rowsList: Array<common_gateway_base_pb.ValuesRow.AsObject>,
    totalRows: number,
  }
}

export class ChallengeDecisionRequest extends jspb.Message {
  getAssetId(): string;
  setAssetId(value: string): void;

  getChallengeId(): string;
  setChallengeId(value: string): void;

  getDecision(): common_gateway_base_pb.DecisionMap[keyof common_gateway_base_pb.DecisionMap];
  setDecision(value: common_gateway_base_pb.DecisionMap[keyof common_gateway_base_pb.DecisionMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeDecisionRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeDecisionRequest): ChallengeDecisionRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeDecisionRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeDecisionRequest;
  static deserializeBinaryFromReader(message: ChallengeDecisionRequest, reader: jspb.BinaryReader): ChallengeDecisionRequest;
}

export namespace ChallengeDecisionRequest {
  export type AsObject = {
    assetId: string,
    challengeId: string,
    decision: common_gateway_base_pb.DecisionMap[keyof common_gateway_base_pb.DecisionMap],
  }
}

export class ChallengeHistoryRequest extends jspb.Message {
  getAssetId(): string;
  setAssetId(value: string): void;

  getFilter(): string;
  setFilter(value: string): void;

  hasOrderby(): boolean;
  clearOrderby(): void;
  getOrderby(): common_gateway_base_pb.OrderBy | undefined;
  setOrderby(value?: common_gateway_base_pb.OrderBy): void;

  hasLimit(): boolean;
  clearLimit(): void;
  getLimit(): common_gateway_base_pb.Limit | undefined;
  setLimit(value?: common_gateway_base_pb.Limit): void;

  getOffset(): number;
  setOffset(value: number): void;

  getTraceName(): string;
  setTraceName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeHistoryRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeHistoryRequest): ChallengeHistoryRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeHistoryRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeHistoryRequest;
  static deserializeBinaryFromReader(message: ChallengeHistoryRequest, reader: jspb.BinaryReader): ChallengeHistoryRequest;
}

export namespace ChallengeHistoryRequest {
  export type AsObject = {
    assetId: string,
    filter: string,
    orderby?: common_gateway_base_pb.OrderBy.AsObject,
    limit?: common_gateway_base_pb.Limit.AsObject,
    offset: number,
    traceName: string,
  }
}

export class ChallengeListRequest extends jspb.Message {
  getAssetId(): string;
  setAssetId(value: string): void;

  getConsensusRunTimestamp(): string;
  setConsensusRunTimestamp(value: string): void;

  getSnapTime(): string;
  setSnapTime(value: string): void;

  getDate(): string;
  setDate(value: string): void;

  getFilter(): string;
  setFilter(value: string): void;

  hasOrderby(): boolean;
  clearOrderby(): void;
  getOrderby(): common_gateway_base_pb.OrderBy | undefined;
  setOrderby(value?: common_gateway_base_pb.OrderBy): void;

  hasLimit(): boolean;
  clearLimit(): void;
  getLimit(): common_gateway_base_pb.Limit | undefined;
  setLimit(value?: common_gateway_base_pb.Limit): void;

  getOffset(): number;
  setOffset(value: number): void;

  getTraceName(): string;
  setTraceName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeListRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeListRequest): ChallengeListRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeListRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeListRequest;
  static deserializeBinaryFromReader(message: ChallengeListRequest, reader: jspb.BinaryReader): ChallengeListRequest;
}

export namespace ChallengeListRequest {
  export type AsObject = {
    assetId: string,
    consensusRunTimestamp: string,
    snapTime: string,
    date: string,
    filter: string,
    orderby?: common_gateway_base_pb.OrderBy.AsObject,
    limit?: common_gateway_base_pb.Limit.AsObject,
    offset: number,
    traceName: string,
  }
}

export class ChallengeListResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): ChallengeListResponseData | undefined;
  setData(value?: ChallengeListResponseData): void;

  hasError(): boolean;
  clearError(): void;
  getError(): common_gateway_base_pb.Error | undefined;
  setError(value?: common_gateway_base_pb.Error): void;

  getResponseCase(): ChallengeListResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeListResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeListResponse): ChallengeListResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeListResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeListResponse;
  static deserializeBinaryFromReader(message: ChallengeListResponse, reader: jspb.BinaryReader): ChallengeListResponse;
}

export namespace ChallengeListResponse {
  export type AsObject = {
    data?: ChallengeListResponseData.AsObject,
    error?: common_gateway_base_pb.Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class ChallengeListResponseData extends jspb.Message {
  clearColumnsList(): void;
  getColumnsList(): Array<common_gateway_base_pb.ColumnInfo>;
  setColumnsList(value: Array<common_gateway_base_pb.ColumnInfo>): void;
  addColumns(value?: common_gateway_base_pb.ColumnInfo, index?: number): common_gateway_base_pb.ColumnInfo;

  clearChallengesList(): void;
  getChallengesList(): Array<ChallengeListMetadata>;
  setChallengesList(value: Array<ChallengeListMetadata>): void;
  addChallenges(value?: ChallengeListMetadata, index?: number): ChallengeListMetadata;

  getTotalRows(): number;
  setTotalRows(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeListResponseData.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeListResponseData): ChallengeListResponseData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeListResponseData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeListResponseData;
  static deserializeBinaryFromReader(message: ChallengeListResponseData, reader: jspb.BinaryReader): ChallengeListResponseData;
}

export namespace ChallengeListResponseData {
  export type AsObject = {
    columnsList: Array<common_gateway_base_pb.ColumnInfo.AsObject>,
    challengesList: Array<ChallengeListMetadata.AsObject>,
    totalRows: number,
  }
}

export class ChallengeListMetadata extends jspb.Message {
  clearValuesList(): void;
  getValuesList(): Array<google_protobuf_struct_pb.Value>;
  setValuesList(value: Array<google_protobuf_struct_pb.Value>): void;
  addValues(value?: google_protobuf_struct_pb.Value, index?: number): google_protobuf_struct_pb.Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChallengeListMetadata.AsObject;
  static toObject(includeInstance: boolean, msg: ChallengeListMetadata): ChallengeListMetadata.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChallengeListMetadata, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChallengeListMetadata;
  static deserializeBinaryFromReader(message: ChallengeListMetadata, reader: jspb.BinaryReader): ChallengeListMetadata;
}

export namespace ChallengeListMetadata {
  export type AsObject = {
    valuesList: Array<google_protobuf_struct_pb.Value.AsObject>,
  }
}

export class GetAttachmentUploadUrlRequest extends jspb.Message {
  getAssetId(): string;
  setAssetId(value: string): void;

  getSubmittedId(): string;
  setSubmittedId(value: string): void;

  getFileName(): string;
  setFileName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetAttachmentUploadUrlRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetAttachmentUploadUrlRequest): GetAttachmentUploadUrlRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetAttachmentUploadUrlRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetAttachmentUploadUrlRequest;
  static deserializeBinaryFromReader(message: GetAttachmentUploadUrlRequest, reader: jspb.BinaryReader): GetAttachmentUploadUrlRequest;
}

export namespace GetAttachmentUploadUrlRequest {
  export type AsObject = {
    assetId: string,
    submittedId: string,
    fileName: string,
  }
}

export class GetAttachmentUploadUrlResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): GetAttachmentUploadUrlResponse.AttachmentUploadUrl | undefined;
  setData(value?: GetAttachmentUploadUrlResponse.AttachmentUploadUrl): void;

  hasError(): boolean;
  clearError(): void;
  getError(): common_gateway_base_pb.Error | undefined;
  setError(value?: common_gateway_base_pb.Error): void;

  getResponseCase(): GetAttachmentUploadUrlResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetAttachmentUploadUrlResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetAttachmentUploadUrlResponse): GetAttachmentUploadUrlResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetAttachmentUploadUrlResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetAttachmentUploadUrlResponse;
  static deserializeBinaryFromReader(message: GetAttachmentUploadUrlResponse, reader: jspb.BinaryReader): GetAttachmentUploadUrlResponse;
}

export namespace GetAttachmentUploadUrlResponse {
  export type AsObject = {
    data?: GetAttachmentUploadUrlResponse.AttachmentUploadUrl.AsObject,
    error?: common_gateway_base_pb.Error.AsObject,
  }

  export class AttachmentUploadUrl extends jspb.Message {
    getUploadUrl(): string;
    setUploadUrl(value: string): void;

    getAttachmentId(): string;
    setAttachmentId(value: string): void;

    getFileName(): string;
    setFileName(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AttachmentUploadUrl.AsObject;
    static toObject(includeInstance: boolean, msg: AttachmentUploadUrl): AttachmentUploadUrl.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AttachmentUploadUrl, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AttachmentUploadUrl;
    static deserializeBinaryFromReader(message: AttachmentUploadUrl, reader: jspb.BinaryReader): AttachmentUploadUrl;
  }

  export namespace AttachmentUploadUrl {
    export type AsObject = {
      uploadUrl: string,
      attachmentId: string,
      fileName: string,
    }
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class Attachment extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getAttachmentId(): string;
  setAttachmentId(value: string): void;

  getUrl(): string;
  setUrl(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Attachment.AsObject;
  static toObject(includeInstance: boolean, msg: Attachment): Attachment.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Attachment, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Attachment;
  static deserializeBinaryFromReader(message: Attachment, reader: jspb.BinaryReader): Attachment;
}

export namespace Attachment {
  export type AsObject = {
    name: string,
    attachmentId: string,
    url: string,
  }
}

export class GetChallengeDetailsRequest extends jspb.Message {
  getAssetId(): string;
  setAssetId(value: string): void;

  getSubmittedDate(): string;
  setSubmittedDate(value: string): void;

  getSubmissionId(): string;
  setSubmissionId(value: string): void;

  getTraceName(): string;
  setTraceName(value: string): void;

  getConsensusRunId(): string;
  setConsensusRunId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetChallengeDetailsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetChallengeDetailsRequest): GetChallengeDetailsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetChallengeDetailsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetChallengeDetailsRequest;
  static deserializeBinaryFromReader(message: GetChallengeDetailsRequest, reader: jspb.BinaryReader): GetChallengeDetailsRequest;
}

export namespace GetChallengeDetailsRequest {
  export type AsObject = {
    assetId: string,
    submittedDate: string,
    submissionId: string,
    traceName: string,
    consensusRunId: string,
  }
}

export class GetChallengeDetailsResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): GetChallengeDetailsResponse.Result | undefined;
  setData(value?: GetChallengeDetailsResponse.Result): void;

  hasError(): boolean;
  clearError(): void;
  getError(): common_gateway_base_pb.Error | undefined;
  setError(value?: common_gateway_base_pb.Error): void;

  getResponseCase(): GetChallengeDetailsResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetChallengeDetailsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetChallengeDetailsResponse): GetChallengeDetailsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetChallengeDetailsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetChallengeDetailsResponse;
  static deserializeBinaryFromReader(message: GetChallengeDetailsResponse, reader: jspb.BinaryReader): GetChallengeDetailsResponse;
}

export namespace GetChallengeDetailsResponse {
  export type AsObject = {
    data?: GetChallengeDetailsResponse.Result.AsObject,
    error?: common_gateway_base_pb.Error.AsObject,
  }

  export class Result extends jspb.Message {
    getChallengeDataMap(): jspb.Map<string, string>;
    clearChallengeDataMap(): void;
    hasCommonChallengeData(): boolean;
    clearCommonChallengeData(): void;
    getCommonChallengeData(): GetChallengeDetailsResponse.CommonChallengeData | undefined;
    setCommonChallengeData(value?: GetChallengeDetailsResponse.CommonChallengeData): void;

    clearAttachmentsList(): void;
    getAttachmentsList(): Array<Attachment>;
    setAttachmentsList(value: Array<Attachment>): void;
    addAttachments(value?: Attachment, index?: number): Attachment;

    getTotalnumberMap(): jspb.Map<string, number>;
    clearTotalnumberMap(): void;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Result.AsObject;
    static toObject(includeInstance: boolean, msg: Result): Result.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Result, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Result;
    static deserializeBinaryFromReader(message: Result, reader: jspb.BinaryReader): Result;
  }

  export namespace Result {
    export type AsObject = {
      challengeDataMap: Array<[string, string]>,
      commonChallengeData?: GetChallengeDetailsResponse.CommonChallengeData.AsObject,
      attachmentsList: Array<Attachment.AsObject>,
      totalnumberMap: Array<[string, number]>,
    }
  }

  export class CommonChallengeData extends jspb.Message {
    getDate(): string;
    setDate(value: string): void;

    getTime(): string;
    setTime(value: string): void;

    getEvidenceType(): string;
    setEvidenceType(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): CommonChallengeData.AsObject;
    static toObject(includeInstance: boolean, msg: CommonChallengeData): CommonChallengeData.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: CommonChallengeData, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): CommonChallengeData;
    static deserializeBinaryFromReader(message: CommonChallengeData, reader: jspb.BinaryReader): CommonChallengeData;
  }

  export namespace CommonChallengeData {
    export type AsObject = {
      date: string,
      time: string,
      evidenceType: string,
    }
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export interface ChallengeFreezeActionMap {
  CHALLENGE_FREEZE_ACTION_UNSPECIFIED: 0;
  CHALLENGE_FREEZE_ACTION_ENABLE: 1;
  CHALLENGE_FREEZE_ACTION_DISABLE: 2;
}

export const ChallengeFreezeAction: ChallengeFreezeActionMap;

export interface EvidenceTypeMap {
  EVIDENCE_TYPE_UNSPECIFIED: 0;
  TRADE: 1;
  ORDER: 2;
}

export const EvidenceType: EvidenceTypeMap;

