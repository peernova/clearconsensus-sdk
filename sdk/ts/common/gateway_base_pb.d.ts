/* eslint-disable */
/*Generated by GenDocu.com*/
// package: titanium
// file: common/gateway_base.proto

import * as jspb from "google-protobuf";
import * as google_protobuf_struct_pb from "google-protobuf/google/protobuf/struct_pb";

export class Error extends jspb.Message {
  getCode(): number;
  setCode(value: number): void;

  getMessage(): string;
  setMessage(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Error.AsObject;
  static toObject(includeInstance: boolean, msg: Error): Error.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Error, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Error;
  static deserializeBinaryFromReader(message: Error, reader: jspb.BinaryReader): Error;
}

export namespace Error {
  export type AsObject = {
    code: number,
    message: string,
  }
}

export class RangePoint extends jspb.Message {
  getLabel(): string;
  setLabel(value: string): void;

  hasValue(): boolean;
  clearValue(): void;
  getValue(): google_protobuf_struct_pb.Value | undefined;
  setValue(value?: google_protobuf_struct_pb.Value): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RangePoint.AsObject;
  static toObject(includeInstance: boolean, msg: RangePoint): RangePoint.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RangePoint, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RangePoint;
  static deserializeBinaryFromReader(message: RangePoint, reader: jspb.BinaryReader): RangePoint;
}

export namespace RangePoint {
  export type AsObject = {
    label: string,
    value?: google_protobuf_struct_pb.Value.AsObject,
  }
}

export class Identifier extends jspb.Message {
  getUid(): string;
  setUid(value: string): void;

  getName(): string;
  setName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Identifier.AsObject;
  static toObject(includeInstance: boolean, msg: Identifier): Identifier.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Identifier, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Identifier;
  static deserializeBinaryFromReader(message: Identifier, reader: jspb.BinaryReader): Identifier;
}

export namespace Identifier {
  export type AsObject = {
    uid: string,
    name: string,
  }
}

export class GetDefinition extends jspb.Message {
  hasIdentifier(): boolean;
  clearIdentifier(): void;
  getIdentifier(): Identifier | undefined;
  setIdentifier(value?: Identifier): void;

  getScope(): string;
  setScope(value: string): void;

  getDescriptorName(): string;
  setDescriptorName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetDefinition.AsObject;
  static toObject(includeInstance: boolean, msg: GetDefinition): GetDefinition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetDefinition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetDefinition;
  static deserializeBinaryFromReader(message: GetDefinition, reader: jspb.BinaryReader): GetDefinition;
}

export namespace GetDefinition {
  export type AsObject = {
    identifier?: Identifier.AsObject,
    scope: string,
    descriptorName: string,
  }
}

export class Limit extends jspb.Message {
  getValue(): number;
  setValue(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Limit.AsObject;
  static toObject(includeInstance: boolean, msg: Limit): Limit.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Limit, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Limit;
  static deserializeBinaryFromReader(message: Limit, reader: jspb.BinaryReader): Limit;
}

export namespace Limit {
  export type AsObject = {
    value: number,
  }
}

export class OrderBy extends jspb.Message {
  getColumn(): string;
  setColumn(value: string): void;

  getOrder(): OrderMap[keyof OrderMap];
  setOrder(value: OrderMap[keyof OrderMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OrderBy.AsObject;
  static toObject(includeInstance: boolean, msg: OrderBy): OrderBy.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OrderBy, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OrderBy;
  static deserializeBinaryFromReader(message: OrderBy, reader: jspb.BinaryReader): OrderBy;
}

export namespace OrderBy {
  export type AsObject = {
    column: string,
    order: OrderMap[keyof OrderMap],
  }
}

export class ListRequest extends jspb.Message {
  getScope(): string;
  setScope(value: string): void;

  getFilter(): string;
  setFilter(value: string): void;

  hasOrderby(): boolean;
  clearOrderby(): void;
  getOrderby(): OrderBy | undefined;
  setOrderby(value?: OrderBy): void;

  hasLimit(): boolean;
  clearLimit(): void;
  getLimit(): Limit | undefined;
  setLimit(value?: Limit): void;

  getOffset(): number;
  setOffset(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ListRequest): ListRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListRequest;
  static deserializeBinaryFromReader(message: ListRequest, reader: jspb.BinaryReader): ListRequest;
}

export namespace ListRequest {
  export type AsObject = {
    scope: string,
    filter: string,
    orderby?: OrderBy.AsObject,
    limit?: Limit.AsObject,
    offset: number,
  }
}

export class AcknowledgeResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): Identifier | undefined;
  setData(value?: Identifier): void;

  hasError(): boolean;
  clearError(): void;
  getError(): Error | undefined;
  setError(value?: Error): void;

  getResponseCase(): AcknowledgeResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AcknowledgeResponse.AsObject;
  static toObject(includeInstance: boolean, msg: AcknowledgeResponse): AcknowledgeResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AcknowledgeResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AcknowledgeResponse;
  static deserializeBinaryFromReader(message: AcknowledgeResponse, reader: jspb.BinaryReader): AcknowledgeResponse;
}

export namespace AcknowledgeResponse {
  export type AsObject = {
    data?: Identifier.AsObject,
    error?: Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class Version extends jspb.Message {
  getVersionId(): string;
  setVersionId(value: string): void;

  getCreatedAt(): string;
  setCreatedAt(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Version.AsObject;
  static toObject(includeInstance: boolean, msg: Version): Version.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Version, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Version;
  static deserializeBinaryFromReader(message: Version, reader: jspb.BinaryReader): Version;
}

export namespace Version {
  export type AsObject = {
    versionId: string,
    createdAt: string,
  }
}

export class VersionList extends jspb.Message {
  clearVersionsList(): void;
  getVersionsList(): Array<Version>;
  setVersionsList(value: Array<Version>): void;
  addVersions(value?: Version, index?: number): Version;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): VersionList.AsObject;
  static toObject(includeInstance: boolean, msg: VersionList): VersionList.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: VersionList, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): VersionList;
  static deserializeBinaryFromReader(message: VersionList, reader: jspb.BinaryReader): VersionList;
}

export namespace VersionList {
  export type AsObject = {
    versionsList: Array<Version.AsObject>,
  }
}

export class ListVersionResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): VersionList | undefined;
  setData(value?: VersionList): void;

  hasError(): boolean;
  clearError(): void;
  getError(): Error | undefined;
  setError(value?: Error): void;

  getResponseCase(): ListVersionResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListVersionResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ListVersionResponse): ListVersionResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListVersionResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListVersionResponse;
  static deserializeBinaryFromReader(message: ListVersionResponse, reader: jspb.BinaryReader): ListVersionResponse;
}

export namespace ListVersionResponse {
  export type AsObject = {
    data?: VersionList.AsObject,
    error?: Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class VersionRequest extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getVersionId(): string;
  setVersionId(value: string): void;

  getScope(): string;
  setScope(value: string): void;

  getDescriptorName(): string;
  setDescriptorName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): VersionRequest.AsObject;
  static toObject(includeInstance: boolean, msg: VersionRequest): VersionRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: VersionRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): VersionRequest;
  static deserializeBinaryFromReader(message: VersionRequest, reader: jspb.BinaryReader): VersionRequest;
}

export namespace VersionRequest {
  export type AsObject = {
    name: string,
    versionId: string,
    scope: string,
    descriptorName: string,
  }
}

export class DescriptorField extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getType(): string;
  setType(value: string): void;

  hasOptions(): boolean;
  clearOptions(): void;
  getOptions(): google_protobuf_struct_pb.Struct | undefined;
  setOptions(value?: google_protobuf_struct_pb.Struct): void;

  getNullable(): boolean;
  setNullable(value: boolean): void;

  getAlias(): string;
  setAlias(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DescriptorField.AsObject;
  static toObject(includeInstance: boolean, msg: DescriptorField): DescriptorField.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DescriptorField, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DescriptorField;
  static deserializeBinaryFromReader(message: DescriptorField, reader: jspb.BinaryReader): DescriptorField;
}

export namespace DescriptorField {
  export type AsObject = {
    name: string,
    type: string,
    options?: google_protobuf_struct_pb.Struct.AsObject,
    nullable: boolean,
    alias: string,
  }
}

export class DescriptorDefinition extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  clearFieldsList(): void;
  getFieldsList(): Array<DescriptorField>;
  setFieldsList(value: Array<DescriptorField>): void;
  addFields(value?: DescriptorField, index?: number): DescriptorField;

  hasOptions(): boolean;
  clearOptions(): void;
  getOptions(): google_protobuf_struct_pb.Struct | undefined;
  setOptions(value?: google_protobuf_struct_pb.Struct): void;

  getScope(): string;
  setScope(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DescriptorDefinition.AsObject;
  static toObject(includeInstance: boolean, msg: DescriptorDefinition): DescriptorDefinition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DescriptorDefinition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DescriptorDefinition;
  static deserializeBinaryFromReader(message: DescriptorDefinition, reader: jspb.BinaryReader): DescriptorDefinition;
}

export namespace DescriptorDefinition {
  export type AsObject = {
    name: string,
    fieldsList: Array<DescriptorField.AsObject>,
    options?: google_protobuf_struct_pb.Struct.AsObject,
    scope: string,
  }
}

export class MessageResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): MessageResponseData | undefined;
  setData(value?: MessageResponseData): void;

  hasError(): boolean;
  clearError(): void;
  getError(): Error | undefined;
  setError(value?: Error): void;

  getResponseCase(): MessageResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MessageResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MessageResponse): MessageResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MessageResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MessageResponse;
  static deserializeBinaryFromReader(message: MessageResponse, reader: jspb.BinaryReader): MessageResponse;
}

export namespace MessageResponse {
  export type AsObject = {
    data?: MessageResponseData.AsObject,
    error?: Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class MessageResponseData extends jspb.Message {
  getMessage(): string;
  setMessage(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MessageResponseData.AsObject;
  static toObject(includeInstance: boolean, msg: MessageResponseData): MessageResponseData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MessageResponseData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MessageResponseData;
  static deserializeBinaryFromReader(message: MessageResponseData, reader: jspb.BinaryReader): MessageResponseData;
}

export namespace MessageResponseData {
  export type AsObject = {
    message: string,
  }
}

export class Transformation extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getTargetColumn(): string;
  setTargetColumn(value: string): void;

  getSourceColumn(): string;
  setSourceColumn(value: string): void;

  getRule(): string;
  setRule(value: string): void;

  hasLut(): boolean;
  clearLut(): void;
  getLut(): DynamicLut | undefined;
  setLut(value?: DynamicLut): void;

  getDescription(): string;
  setDescription(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Transformation.AsObject;
  static toObject(includeInstance: boolean, msg: Transformation): Transformation.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Transformation, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Transformation;
  static deserializeBinaryFromReader(message: Transformation, reader: jspb.BinaryReader): Transformation;
}

export namespace Transformation {
  export type AsObject = {
    name: string,
    targetColumn: string,
    sourceColumn: string,
    rule: string,
    lut?: DynamicLut.AsObject,
    description: string,
  }
}

export class ResultsList extends jspb.Message {
  clearResultsList(): void;
  getResultsList(): Array<Identifier>;
  setResultsList(value: Array<Identifier>): void;
  addResults(value?: Identifier, index?: number): Identifier;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ResultsList.AsObject;
  static toObject(includeInstance: boolean, msg: ResultsList): ResultsList.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ResultsList, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ResultsList;
  static deserializeBinaryFromReader(message: ResultsList, reader: jspb.BinaryReader): ResultsList;
}

export namespace ResultsList {
  export type AsObject = {
    resultsList: Array<Identifier.AsObject>,
  }
}

export class ColumnInfo extends jspb.Message {
  getColumnname(): string;
  setColumnname(value: string): void;

  getRawcolumnname(): string;
  setRawcolumnname(value: string): void;

  getColumntype(): string;
  setColumntype(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ColumnInfo.AsObject;
  static toObject(includeInstance: boolean, msg: ColumnInfo): ColumnInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ColumnInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ColumnInfo;
  static deserializeBinaryFromReader(message: ColumnInfo, reader: jspb.BinaryReader): ColumnInfo;
}

export namespace ColumnInfo {
  export type AsObject = {
    columnname: string,
    rawcolumnname: string,
    columntype: string,
  }
}

export class ListRuleResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): DescriptorBasedResultsList | undefined;
  setData(value?: DescriptorBasedResultsList): void;

  hasError(): boolean;
  clearError(): void;
  getError(): Error | undefined;
  setError(value?: Error): void;

  getResponseCase(): ListRuleResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListRuleResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ListRuleResponse): ListRuleResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListRuleResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListRuleResponse;
  static deserializeBinaryFromReader(message: ListRuleResponse, reader: jspb.BinaryReader): ListRuleResponse;
}

export namespace ListRuleResponse {
  export type AsObject = {
    data?: DescriptorBasedResultsList.AsObject,
    error?: Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class DescriptorBasedResultsList extends jspb.Message {
  clearResultsList(): void;
  getResultsList(): Array<DescriptorBasedIdentifier>;
  setResultsList(value: Array<DescriptorBasedIdentifier>): void;
  addResults(value?: DescriptorBasedIdentifier, index?: number): DescriptorBasedIdentifier;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DescriptorBasedResultsList.AsObject;
  static toObject(includeInstance: boolean, msg: DescriptorBasedResultsList): DescriptorBasedResultsList.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DescriptorBasedResultsList, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DescriptorBasedResultsList;
  static deserializeBinaryFromReader(message: DescriptorBasedResultsList, reader: jspb.BinaryReader): DescriptorBasedResultsList;
}

export namespace DescriptorBasedResultsList {
  export type AsObject = {
    resultsList: Array<DescriptorBasedIdentifier.AsObject>,
  }
}

export class DescriptorBasedIdentifier extends jspb.Message {
  getUid(): string;
  setUid(value: string): void;

  getDescriptorName(): string;
  setDescriptorName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DescriptorBasedIdentifier.AsObject;
  static toObject(includeInstance: boolean, msg: DescriptorBasedIdentifier): DescriptorBasedIdentifier.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DescriptorBasedIdentifier, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DescriptorBasedIdentifier;
  static deserializeBinaryFromReader(message: DescriptorBasedIdentifier, reader: jspb.BinaryReader): DescriptorBasedIdentifier;
}

export namespace DescriptorBasedIdentifier {
  export type AsObject = {
    uid: string,
    descriptorName: string,
  }
}

export class ValuesRow extends jspb.Message {
  clearValuesList(): void;
  getValuesList(): Array<google_protobuf_struct_pb.Value>;
  setValuesList(value: Array<google_protobuf_struct_pb.Value>): void;
  addValues(value?: google_protobuf_struct_pb.Value, index?: number): google_protobuf_struct_pb.Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ValuesRow.AsObject;
  static toObject(includeInstance: boolean, msg: ValuesRow): ValuesRow.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ValuesRow, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ValuesRow;
  static deserializeBinaryFromReader(message: ValuesRow, reader: jspb.BinaryReader): ValuesRow;
}

export namespace ValuesRow {
  export type AsObject = {
    valuesList: Array<google_protobuf_struct_pb.Value.AsObject>,
  }
}

export class ResponseData extends jspb.Message {
  clearColumnsList(): void;
  getColumnsList(): Array<ColumnInfo>;
  setColumnsList(value: Array<ColumnInfo>): void;
  addColumns(value?: ColumnInfo, index?: number): ColumnInfo;

  clearRowsList(): void;
  getRowsList(): Array<ValuesRow>;
  setRowsList(value: Array<ValuesRow>): void;
  addRows(value?: ValuesRow, index?: number): ValuesRow;

  hasPage(): boolean;
  clearPage(): void;
  getPage(): Page | undefined;
  setPage(value?: Page): void;

  getTotalRows(): number;
  setTotalRows(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ResponseData.AsObject;
  static toObject(includeInstance: boolean, msg: ResponseData): ResponseData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ResponseData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ResponseData;
  static deserializeBinaryFromReader(message: ResponseData, reader: jspb.BinaryReader): ResponseData;
}

export namespace ResponseData {
  export type AsObject = {
    columnsList: Array<ColumnInfo.AsObject>,
    rowsList: Array<ValuesRow.AsObject>,
    page?: Page.AsObject,
    totalRows: number,
  }
}

export class StatusResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): StatusResponseData | undefined;
  setData(value?: StatusResponseData): void;

  hasError(): boolean;
  clearError(): void;
  getError(): Error | undefined;
  setError(value?: Error): void;

  getResponseCase(): StatusResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StatusResponse.AsObject;
  static toObject(includeInstance: boolean, msg: StatusResponse): StatusResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StatusResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StatusResponse;
  static deserializeBinaryFromReader(message: StatusResponse, reader: jspb.BinaryReader): StatusResponse;
}

export namespace StatusResponse {
  export type AsObject = {
    data?: StatusResponseData.AsObject,
    error?: Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class StatusResponseData extends jspb.Message {
  getStatus(): string;
  setStatus(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StatusResponseData.AsObject;
  static toObject(includeInstance: boolean, msg: StatusResponseData): StatusResponseData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StatusResponseData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StatusResponseData;
  static deserializeBinaryFromReader(message: StatusResponseData, reader: jspb.BinaryReader): StatusResponseData;
}

export namespace StatusResponseData {
  export type AsObject = {
    status: string,
  }
}

export class ConsensusActiveResponse extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): ResponseData | undefined;
  setData(value?: ResponseData): void;

  hasError(): boolean;
  clearError(): void;
  getError(): Error | undefined;
  setError(value?: Error): void;

  getResponseCase(): ConsensusActiveResponse.ResponseCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConsensusActiveResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ConsensusActiveResponse): ConsensusActiveResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConsensusActiveResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConsensusActiveResponse;
  static deserializeBinaryFromReader(message: ConsensusActiveResponse, reader: jspb.BinaryReader): ConsensusActiveResponse;
}

export namespace ConsensusActiveResponse {
  export type AsObject = {
    data?: ResponseData.AsObject,
    error?: Error.AsObject,
  }

  export enum ResponseCase {
    RESPONSE_NOT_SET = 0,
    DATA = 1,
    ERROR = 2,
  }
}

export class DataQualityError extends jspb.Message {
  getMessage(): string;
  setMessage(value: string): void;

  getSeverity(): number;
  setSeverity(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DataQualityError.AsObject;
  static toObject(includeInstance: boolean, msg: DataQualityError): DataQualityError.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DataQualityError, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DataQualityError;
  static deserializeBinaryFromReader(message: DataQualityError, reader: jspb.BinaryReader): DataQualityError;
}

export namespace DataQualityError {
  export type AsObject = {
    message: string,
    severity: number,
  }
}

export class ConsensusDetail extends jspb.Message {
  getParseStatus(): string;
  setParseStatus(value: string): void;

  getHighestSev(): string;
  setHighestSev(value: string): void;

  getCalculationStatus(): string;
  setCalculationStatus(value: string): void;

  getCalculationDetail(): string;
  setCalculationDetail(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConsensusDetail.AsObject;
  static toObject(includeInstance: boolean, msg: ConsensusDetail): ConsensusDetail.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConsensusDetail, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConsensusDetail;
  static deserializeBinaryFromReader(message: ConsensusDetail, reader: jspb.BinaryReader): ConsensusDetail;
}

export namespace ConsensusDetail {
  export type AsObject = {
    parseStatus: string,
    highestSev: string,
    calculationStatus: string,
    calculationDetail: string,
  }
}

export class DataQualityErrors extends jspb.Message {
  clearErrorsList(): void;
  getErrorsList(): Array<DataQualityError>;
  setErrorsList(value: Array<DataQualityError>): void;
  addErrors(value?: DataQualityError, index?: number): DataQualityError;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DataQualityErrors.AsObject;
  static toObject(includeInstance: boolean, msg: DataQualityErrors): DataQualityErrors.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DataQualityErrors, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DataQualityErrors;
  static deserializeBinaryFromReader(message: DataQualityErrors, reader: jspb.BinaryReader): DataQualityErrors;
}

export namespace DataQualityErrors {
  export type AsObject = {
    errorsList: Array<DataQualityError.AsObject>,
  }
}

export class StringKeyVal extends jspb.Message {
  getKey(): string;
  setKey(value: string): void;

  getVal(): string;
  setVal(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StringKeyVal.AsObject;
  static toObject(includeInstance: boolean, msg: StringKeyVal): StringKeyVal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StringKeyVal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StringKeyVal;
  static deserializeBinaryFromReader(message: StringKeyVal, reader: jspb.BinaryReader): StringKeyVal;
}

export namespace StringKeyVal {
  export type AsObject = {
    key: string,
    val: string,
  }
}

export class BenchmarkMetadata extends jspb.Message {
  getTenor(): string;
  setTenor(value: string): void;

  getReason(): string;
  setReason(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BenchmarkMetadata.AsObject;
  static toObject(includeInstance: boolean, msg: BenchmarkMetadata): BenchmarkMetadata.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BenchmarkMetadata, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BenchmarkMetadata;
  static deserializeBinaryFromReader(message: BenchmarkMetadata, reader: jspb.BinaryReader): BenchmarkMetadata;
}

export namespace BenchmarkMetadata {
  export type AsObject = {
    tenor: string,
    reason: string,
  }
}

export class OutlierMetadata extends jspb.Message {
  getTenor(): string;
  setTenor(value: string): void;

  getReason(): string;
  setReason(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OutlierMetadata.AsObject;
  static toObject(includeInstance: boolean, msg: OutlierMetadata): OutlierMetadata.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OutlierMetadata, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OutlierMetadata;
  static deserializeBinaryFromReader(message: OutlierMetadata, reader: jspb.BinaryReader): OutlierMetadata;
}

export namespace OutlierMetadata {
  export type AsObject = {
    tenor: string,
    reason: string,
  }
}

export class Fields extends jspb.Message {
  clearGroupingkeysList(): void;
  getGroupingkeysList(): Array<ColumnInfo>;
  setGroupingkeysList(value: Array<ColumnInfo>): void;
  addGroupingkeys(value?: ColumnInfo, index?: number): ColumnInfo;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Fields.AsObject;
  static toObject(includeInstance: boolean, msg: Fields): Fields.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Fields, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Fields;
  static deserializeBinaryFromReader(message: Fields, reader: jspb.BinaryReader): Fields;
}

export namespace Fields {
  export type AsObject = {
    groupingkeysList: Array<ColumnInfo.AsObject>,
  }
}

export class Values extends jspb.Message {
  getType(): string;
  setType(value: string): void;

  clearValuesList(): void;
  getValuesList(): Array<google_protobuf_struct_pb.Value>;
  setValuesList(value: Array<google_protobuf_struct_pb.Value>): void;
  addValues(value?: google_protobuf_struct_pb.Value, index?: number): google_protobuf_struct_pb.Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Values.AsObject;
  static toObject(includeInstance: boolean, msg: Values): Values.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Values, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Values;
  static deserializeBinaryFromReader(message: Values, reader: jspb.BinaryReader): Values;
}

export namespace Values {
  export type AsObject = {
    type: string,
    valuesList: Array<google_protobuf_struct_pb.Value.AsObject>,
  }
}

export class UploadURLResponse extends jspb.Message {
  getS3Url(): string;
  setS3Url(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): UploadURLResponse.AsObject;
  static toObject(includeInstance: boolean, msg: UploadURLResponse): UploadURLResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UploadURLResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UploadURLResponse;
  static deserializeBinaryFromReader(message: UploadURLResponse, reader: jspb.BinaryReader): UploadURLResponse;
}

export namespace UploadURLResponse {
  export type AsObject = {
    s3Url: string,
  }
}

export class Filter extends jspb.Message {
  getKey(): string;
  setKey(value: string): void;

  getOperator(): string;
  setOperator(value: string): void;

  hasValue(): boolean;
  clearValue(): void;
  getValue(): google_protobuf_struct_pb.Value | undefined;
  setValue(value?: google_protobuf_struct_pb.Value): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Filter.AsObject;
  static toObject(includeInstance: boolean, msg: Filter): Filter.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Filter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Filter;
  static deserializeBinaryFromReader(message: Filter, reader: jspb.BinaryReader): Filter;
}

export namespace Filter {
  export type AsObject = {
    key: string,
    operator: string,
    value?: google_protobuf_struct_pb.Value.AsObject,
  }
}

export class PredefinedFilter extends jspb.Message {
  getKey(): string;
  setKey(value: string): void;

  getOperator(): string;
  setOperator(value: string): void;

  hasValue(): boolean;
  clearValue(): void;
  getValue(): google_protobuf_struct_pb.Value | undefined;
  setValue(value?: google_protobuf_struct_pb.Value): void;

  getResultcount(): number;
  setResultcount(value: number): void;

  getPredefinedvaluelabel(): string;
  setPredefinedvaluelabel(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PredefinedFilter.AsObject;
  static toObject(includeInstance: boolean, msg: PredefinedFilter): PredefinedFilter.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PredefinedFilter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PredefinedFilter;
  static deserializeBinaryFromReader(message: PredefinedFilter, reader: jspb.BinaryReader): PredefinedFilter;
}

export namespace PredefinedFilter {
  export type AsObject = {
    key: string,
    operator: string,
    value?: google_protobuf_struct_pb.Value.AsObject,
    resultcount: number,
    predefinedvaluelabel: string,
  }
}

export class NameAliasPair extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getAlias(): string;
  setAlias(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NameAliasPair.AsObject;
  static toObject(includeInstance: boolean, msg: NameAliasPair): NameAliasPair.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NameAliasPair, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NameAliasPair;
  static deserializeBinaryFromReader(message: NameAliasPair, reader: jspb.BinaryReader): NameAliasPair;
}

export namespace NameAliasPair {
  export type AsObject = {
    name: string,
    alias: string,
  }
}

export class GenericChartResponse extends jspb.Message {
  clearColumnsList(): void;
  getColumnsList(): Array<ColumnInfo>;
  setColumnsList(value: Array<ColumnInfo>): void;
  addColumns(value?: ColumnInfo, index?: number): ColumnInfo;

  clearRowsList(): void;
  getRowsList(): Array<GenericChartResponseRow>;
  setRowsList(value: Array<GenericChartResponseRow>): void;
  addRows(value?: GenericChartResponseRow, index?: number): GenericChartResponseRow;

  getTotalRows(): number;
  setTotalRows(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GenericChartResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GenericChartResponse): GenericChartResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GenericChartResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GenericChartResponse;
  static deserializeBinaryFromReader(message: GenericChartResponse, reader: jspb.BinaryReader): GenericChartResponse;
}

export namespace GenericChartResponse {
  export type AsObject = {
    columnsList: Array<ColumnInfo.AsObject>,
    rowsList: Array<GenericChartResponseRow.AsObject>,
    totalRows: number,
  }
}

export class GenericChartResponseRow extends jspb.Message {
  clearValuesList(): void;
  getValuesList(): Array<google_protobuf_struct_pb.Value>;
  setValuesList(value: Array<google_protobuf_struct_pb.Value>): void;
  addValues(value?: google_protobuf_struct_pb.Value, index?: number): google_protobuf_struct_pb.Value;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GenericChartResponseRow.AsObject;
  static toObject(includeInstance: boolean, msg: GenericChartResponseRow): GenericChartResponseRow.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GenericChartResponseRow, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GenericChartResponseRow;
  static deserializeBinaryFromReader(message: GenericChartResponseRow, reader: jspb.BinaryReader): GenericChartResponseRow;
}

export namespace GenericChartResponseRow {
  export type AsObject = {
    valuesList: Array<google_protobuf_struct_pb.Value.AsObject>,
  }
}

export class EnableDisableRequest extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getScope(): string;
  setScope(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EnableDisableRequest.AsObject;
  static toObject(includeInstance: boolean, msg: EnableDisableRequest): EnableDisableRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EnableDisableRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EnableDisableRequest;
  static deserializeBinaryFromReader(message: EnableDisableRequest, reader: jspb.BinaryReader): EnableDisableRequest;
}

export namespace EnableDisableRequest {
  export type AsObject = {
    name: string,
    scope: string,
  }
}

export class OutliersListRequest extends jspb.Message {
  getSubmittedDate(): string;
  setSubmittedDate(value: string): void;

  getSubmittedId(): string;
  setSubmittedId(value: string): void;

  getConsensusRunTimestamp(): string;
  setConsensusRunTimestamp(value: string): void;

  getAssetId(): string;
  setAssetId(value: string): void;

  getFilter(): string;
  setFilter(value: string): void;

  hasOrderby(): boolean;
  clearOrderby(): void;
  getOrderby(): OrderBy | undefined;
  setOrderby(value?: OrderBy): void;

  hasLimit(): boolean;
  clearLimit(): void;
  getLimit(): Limit | undefined;
  setLimit(value?: Limit): void;

  getOffset(): number;
  setOffset(value: number): void;

  getTraceName(): string;
  setTraceName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OutliersListRequest.AsObject;
  static toObject(includeInstance: boolean, msg: OutliersListRequest): OutliersListRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OutliersListRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OutliersListRequest;
  static deserializeBinaryFromReader(message: OutliersListRequest, reader: jspb.BinaryReader): OutliersListRequest;
}

export namespace OutliersListRequest {
  export type AsObject = {
    submittedDate: string,
    submittedId: string,
    consensusRunTimestamp: string,
    assetId: string,
    filter: string,
    orderby?: OrderBy.AsObject,
    limit?: Limit.AsObject,
    offset: number,
    traceName: string,
  }
}

export class RulesetDefinition extends jspb.Message {
  getDescriptorName(): string;
  setDescriptorName(value: string): void;

  clearCriteriaList(): void;
  getCriteriaList(): Array<CriteriaDefinition>;
  setCriteriaList(value: Array<CriteriaDefinition>): void;
  addCriteria(value?: CriteriaDefinition, index?: number): CriteriaDefinition;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RulesetDefinition.AsObject;
  static toObject(includeInstance: boolean, msg: RulesetDefinition): RulesetDefinition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RulesetDefinition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RulesetDefinition;
  static deserializeBinaryFromReader(message: RulesetDefinition, reader: jspb.BinaryReader): RulesetDefinition;
}

export namespace RulesetDefinition {
  export type AsObject = {
    descriptorName: string,
    criteriaList: Array<CriteriaDefinition.AsObject>,
  }
}

export class CriteriaDefinition extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getRule(): string;
  setRule(value: string): void;

  clearTagsList(): void;
  getTagsList(): Array<string>;
  setTagsList(value: Array<string>): void;
  addTags(value: string, index?: number): string;

  clearMetadataList(): void;
  getMetadataList(): Array<string>;
  setMetadataList(value: Array<string>): void;
  addMetadata(value: string, index?: number): string;

  clearValidationsList(): void;
  getValidationsList(): Array<RuleDefinition>;
  setValidationsList(value: Array<RuleDefinition>): void;
  addValidations(value?: RuleDefinition, index?: number): RuleDefinition;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CriteriaDefinition.AsObject;
  static toObject(includeInstance: boolean, msg: CriteriaDefinition): CriteriaDefinition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CriteriaDefinition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CriteriaDefinition;
  static deserializeBinaryFromReader(message: CriteriaDefinition, reader: jspb.BinaryReader): CriteriaDefinition;
}

export namespace CriteriaDefinition {
  export type AsObject = {
    name: string,
    description: string,
    rule: string,
    tagsList: Array<string>,
    metadataList: Array<string>,
    validationsList: Array<RuleDefinition.AsObject>,
  }
}

export class RuleDefinition extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getRule(): string;
  setRule(value: string): void;

  getRuleType(): RuleDefinition.RuleTypeMap[keyof RuleDefinition.RuleTypeMap];
  setRuleType(value: RuleDefinition.RuleTypeMap[keyof RuleDefinition.RuleTypeMap]): void;

  getSeverity(): number;
  setSeverity(value: number): void;

  clearTagsList(): void;
  getTagsList(): Array<string>;
  setTagsList(value: Array<string>): void;
  addTags(value: string, index?: number): string;

  hasError(): boolean;
  clearError(): void;
  getError(): ErrorDefinition | undefined;
  setError(value?: ErrorDefinition): void;

  hasLookuptable(): boolean;
  clearLookuptable(): void;
  getLookuptable(): DynamicLut | undefined;
  setLookuptable(value?: DynamicLut): void;

  getFilter(): string;
  setFilter(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RuleDefinition.AsObject;
  static toObject(includeInstance: boolean, msg: RuleDefinition): RuleDefinition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RuleDefinition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RuleDefinition;
  static deserializeBinaryFromReader(message: RuleDefinition, reader: jspb.BinaryReader): RuleDefinition;
}

export namespace RuleDefinition {
  export type AsObject = {
    name: string,
    description: string,
    rule: string,
    ruleType: RuleDefinition.RuleTypeMap[keyof RuleDefinition.RuleTypeMap],
    severity: number,
    tagsList: Array<string>,
    error?: ErrorDefinition.AsObject,
    lookuptable?: DynamicLut.AsObject,
    filter: string,
  }

  export interface RuleTypeMap {
    INPUT_DATA: 0;
    BUSINESS_DATA: 1;
  }

  export const RuleType: RuleTypeMap;
}

export class ErrorDefinition extends jspb.Message {
  getMessage(): string;
  setMessage(value: string): void;

  clearMessageArgsList(): void;
  getMessageArgsList(): Array<string>;
  setMessageArgsList(value: Array<string>): void;
  addMessageArgs(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ErrorDefinition.AsObject;
  static toObject(includeInstance: boolean, msg: ErrorDefinition): ErrorDefinition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ErrorDefinition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ErrorDefinition;
  static deserializeBinaryFromReader(message: ErrorDefinition, reader: jspb.BinaryReader): ErrorDefinition;
}

export namespace ErrorDefinition {
  export type AsObject = {
    message: string,
    messageArgsList: Array<string>,
  }
}

export class DynamicLut extends jspb.Message {
  clearKeyList(): void;
  getKeyList(): Array<string>;
  setKeyList(value: Array<string>): void;
  addKey(value: string, index?: number): string;

  getValue(): string;
  setValue(value: string): void;

  getType(): DynamicLut.DynamicLutTypeMap[keyof DynamicLut.DynamicLutTypeMap];
  setType(value: DynamicLut.DynamicLutTypeMap[keyof DynamicLut.DynamicLutTypeMap]): void;

  getFilter(): string;
  setFilter(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DynamicLut.AsObject;
  static toObject(includeInstance: boolean, msg: DynamicLut): DynamicLut.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DynamicLut, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DynamicLut;
  static deserializeBinaryFromReader(message: DynamicLut, reader: jspb.BinaryReader): DynamicLut;
}

export namespace DynamicLut {
  export type AsObject = {
    keyList: Array<string>,
    value: string,
    type: DynamicLut.DynamicLutTypeMap[keyof DynamicLut.DynamicLutTypeMap],
    filter: string,
  }

  export interface DynamicLutTypeMap {
    BOOLEAN: 0;
    STRING: 1;
    NUMERIC: 2;
    TIMESTAMP: 3;
  }

  export const DynamicLutType: DynamicLutTypeMap;
}

export class FilterPack extends jspb.Message {
  clearFiltersList(): void;
  getFiltersList(): Array<Filter>;
  setFiltersList(value: Array<Filter>): void;
  addFilters(value?: Filter, index?: number): Filter;

  getLogicalOperation(): string;
  setLogicalOperation(value: string): void;

  clearFilterPacksList(): void;
  getFilterPacksList(): Array<FilterPack>;
  setFilterPacksList(value: Array<FilterPack>): void;
  addFilterPacks(value?: FilterPack, index?: number): FilterPack;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FilterPack.AsObject;
  static toObject(includeInstance: boolean, msg: FilterPack): FilterPack.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FilterPack, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FilterPack;
  static deserializeBinaryFromReader(message: FilterPack, reader: jspb.BinaryReader): FilterPack;
}

export namespace FilterPack {
  export type AsObject = {
    filtersList: Array<Filter.AsObject>,
    logicalOperation: string,
    filterPacksList: Array<FilterPack.AsObject>,
  }
}

export class ConsensusRunInfo extends jspb.Message {
  getConsensusRunId(): string;
  setConsensusRunId(value: string): void;

  getRunBy(): string;
  setRunBy(value: string): void;

  getNumberOfParticipants(): number;
  setNumberOfParticipants(value: number): void;

  clearConsensusresultsetinfoList(): void;
  getConsensusresultsetinfoList(): Array<ConsensusResultSetInfo>;
  setConsensusresultsetinfoList(value: Array<ConsensusResultSetInfo>): void;
  addConsensusresultsetinfo(value?: ConsensusResultSetInfo, index?: number): ConsensusResultSetInfo;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConsensusRunInfo.AsObject;
  static toObject(includeInstance: boolean, msg: ConsensusRunInfo): ConsensusRunInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConsensusRunInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConsensusRunInfo;
  static deserializeBinaryFromReader(message: ConsensusRunInfo, reader: jspb.BinaryReader): ConsensusRunInfo;
}

export namespace ConsensusRunInfo {
  export type AsObject = {
    consensusRunId: string,
    runBy: string,
    numberOfParticipants: number,
    consensusresultsetinfoList: Array<ConsensusResultSetInfo.AsObject>,
  }
}

export class ConsensusResultSetInfo extends jspb.Message {
  getConsensusResultSetId(): string;
  setConsensusResultSetId(value: string): void;

  getConsensusRunTimestamp(): string;
  setConsensusRunTimestamp(value: string): void;

  getStatus(): string;
  setStatus(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getType(): string;
  setType(value: string): void;

  getCohortName(): string;
  setCohortName(value: string): void;

  getDataContent(): string;
  setDataContent(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConsensusResultSetInfo.AsObject;
  static toObject(includeInstance: boolean, msg: ConsensusResultSetInfo): ConsensusResultSetInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConsensusResultSetInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConsensusResultSetInfo;
  static deserializeBinaryFromReader(message: ConsensusResultSetInfo, reader: jspb.BinaryReader): ConsensusResultSetInfo;
}

export namespace ConsensusResultSetInfo {
  export type AsObject = {
    consensusResultSetId: string,
    consensusRunTimestamp: string,
    status: string,
    description: string,
    type: string,
    cohortName: string,
    dataContent: string,
  }
}

export class Page extends jspb.Message {
  getSize(): number;
  setSize(value: number): void;

  getPageNumber(): number;
  setPageNumber(value: number): void;

  getTotalNumberOfElements(): number;
  setTotalNumberOfElements(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Page.AsObject;
  static toObject(includeInstance: boolean, msg: Page): Page.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Page, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Page;
  static deserializeBinaryFromReader(message: Page, reader: jspb.BinaryReader): Page;
}

export namespace Page {
  export type AsObject = {
    size: number,
    pageNumber: number,
    totalNumberOfElements: number,
  }
}

export class EntityDefinition extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getScope(): string;
  setScope(value: string): void;

  getType(): EntityTypeMap[keyof EntityTypeMap];
  setType(value: EntityTypeMap[keyof EntityTypeMap]): void;

  getDefinition(): string;
  setDefinition(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EntityDefinition.AsObject;
  static toObject(includeInstance: boolean, msg: EntityDefinition): EntityDefinition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EntityDefinition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EntityDefinition;
  static deserializeBinaryFromReader(message: EntityDefinition, reader: jspb.BinaryReader): EntityDefinition;
}

export namespace EntityDefinition {
  export type AsObject = {
    name: string,
    scope: string,
    type: EntityTypeMap[keyof EntityTypeMap],
    definition: string,
  }
}

export class EntityIdentifier extends jspb.Message {
  hasIdentifier(): boolean;
  clearIdentifier(): void;
  getIdentifier(): Identifier | undefined;
  setIdentifier(value?: Identifier): void;

  getScope(): string;
  setScope(value: string): void;

  getType(): EntityTypeMap[keyof EntityTypeMap];
  setType(value: EntityTypeMap[keyof EntityTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EntityIdentifier.AsObject;
  static toObject(includeInstance: boolean, msg: EntityIdentifier): EntityIdentifier.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EntityIdentifier, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EntityIdentifier;
  static deserializeBinaryFromReader(message: EntityIdentifier, reader: jspb.BinaryReader): EntityIdentifier;
}

export namespace EntityIdentifier {
  export type AsObject = {
    identifier?: Identifier.AsObject,
    scope: string,
    type: EntityTypeMap[keyof EntityTypeMap],
  }
}

export class ListOfKeys extends jspb.Message {
  clearListList(): void;
  getListList(): Array<KeyAndValue>;
  setListList(value: Array<KeyAndValue>): void;
  addList(value?: KeyAndValue, index?: number): KeyAndValue;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListOfKeys.AsObject;
  static toObject(includeInstance: boolean, msg: ListOfKeys): ListOfKeys.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListOfKeys, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListOfKeys;
  static deserializeBinaryFromReader(message: ListOfKeys, reader: jspb.BinaryReader): ListOfKeys;
}

export namespace ListOfKeys {
  export type AsObject = {
    listList: Array<KeyAndValue.AsObject>,
  }
}

export class KeyAndValue extends jspb.Message {
  getKey(): string;
  setKey(value: string): void;

  hasValue(): boolean;
  clearValue(): void;
  getValue(): google_protobuf_struct_pb.Value | undefined;
  setValue(value?: google_protobuf_struct_pb.Value): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): KeyAndValue.AsObject;
  static toObject(includeInstance: boolean, msg: KeyAndValue): KeyAndValue.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: KeyAndValue, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): KeyAndValue;
  static deserializeBinaryFromReader(message: KeyAndValue, reader: jspb.BinaryReader): KeyAndValue;
}

export namespace KeyAndValue {
  export type AsObject = {
    key: string,
    value?: google_protobuf_struct_pb.Value.AsObject,
  }
}

export class Range extends jspb.Message {
  hasMin(): boolean;
  clearMin(): void;
  getMin(): RangePoint | undefined;
  setMin(value?: RangePoint): void;

  hasMax(): boolean;
  clearMax(): void;
  getMax(): RangePoint | undefined;
  setMax(value?: RangePoint): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Range.AsObject;
  static toObject(includeInstance: boolean, msg: Range): Range.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Range, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Range;
  static deserializeBinaryFromReader(message: Range, reader: jspb.BinaryReader): Range;
}

export namespace Range {
  export type AsObject = {
    min?: RangePoint.AsObject,
    max?: RangePoint.AsObject,
  }
}

export interface OrderMap {
  ASC: 0;
  DESC: 1;
}

export const Order: OrderMap;

export interface DecisionMap {
  DECISION_UNSPECIFIED: 0;
  APPROVE: 1;
  DENY: 2;
}

export const Decision: DecisionMap;

export interface EntityTypeMap {
  ADVANCED_TRANSFORM_RULE: 0;
  VALIDATIONRULESET: 1;
  NORMALIZATIONRULESET: 2;
  MAPPINGRULESET: 3;
  CUSTOMFUNCTION: 4;
}

export const EntityType: EntityTypeMap;

